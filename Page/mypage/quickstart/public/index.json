[{"categories":["python基础","多线程"],"content":"懒人回归，开始写一下所学，怕忘记，好记性不如烂笔头。 python被称为解释性语言，那么他是如何实现这种解释的呢？python解释之后是怎么运行的呢？他是怎么实现一些基本操作的？ python的运行 python是怎么运行的呢 执行一个 .py 文件会经历如下过程 如图所示，python是有编译的，所有的python源文件都会在内存中被编译器翻译成由opcode组成字节码指令集, 而 import目录下会被保存成.pyc后缀名的文件，并缓存在执行目录，下次启动程序如果源代码没有修改过，则直接加载这个pyc文件，opcode可以说是一条字节码指令，这种字节码指令都是一个整体，无法分割。 在python虚拟机中，解释器主要在一个很大的循环中，不停地读入 opcode, 并根据opcode执行对应的指令，当执行完所有指令虚拟机退出，程序也就结束了。 main_loop: for (;;) { ... switch (opcode) { /* BEWARE! It is essential that any operation that fails must goto error and that all operation that succeed call [FAST_]DISPATCH() ! */ case TARGET(NOP): { FAST_DISPATCH(); } case TARGET(LOAD_FAST): { PyObject *value = GETLOCAL(oparg); if (value == NULL) { format_exc_check_arg(PyExc_UnboundLocalError, UNBOUNDLOCAL_ERROR_MSG, PyTuple_GetItem(co-\u003eco_varnames, oparg)); goto error; } Py_INCREF(value); PUSH(value); FAST_DISPATCH(); } case TARGET(LOAD_CONST): { PREDICTED(LOAD_CONST); PyObject *value = GETITEM(consts, oparg); Py_INCREF(value); PUSH(value); FAST_DISPATCH(); } ... } } 我们来简单看下 LOAD_CONST 这个指令, 在上面的 switch case 里面。 可以看到，这个指令通过 GETITEM 从 oparg中获取到了一个 python 对象的指针，这个指针的类型是 PyObject * Py_INCREF 作用是把这个 PyObject * 对象的引用计数器加一, 关于引用计数器可以参考 PUSH 的作用是把这个刚刚创建的 PyObject * push 到 当前的 frame 的 stack 上面，以便下一个指令从这个 stack 上面获取 GIL(全局解释锁) 什么是全局解释锁？首先python多线程在运行时，会有一把锁，每个线程都会想要获得这把锁来运行。但CPython并不会允许一个线程独占解释器，它会轮流执行各个线程，这就是我们平时说的伪并行。 上面这张图，就是 GIL 在 Python 程序的工作示例。其中，Thread 1、2、3 轮流执行，每一个线程在开始执行时，都会锁住 GIL，以阻止别的线程执行；同样的，每一个线程执行完一段后，会释放 GIL，以允许别的线程开始利用资源。 读者可能会问，为什么 Python 线程会去主动释放 GIL 呢？毕竟，如果仅仅要求 Python 线程在开始执行时锁住 GIL，且永远不去释放 GIL，那别的线程就都没有运行的机会。其实，CPython 中还有另一个机制，叫做间隔式检查（check_interval），意思是 CPython 解释器会去轮询检查线程 GIL 的锁住情况，每隔一段时间，Python 解释器就会强制当前线程去释放 GIL，这样别的线程才能有执行的机会。 注意，不同版本的 Python，其间隔式检查的实现方式并不一样。早期的 Python 是 100 个刻度（大致对应了 1000 个字节码）；而 Python 3 以后，间隔时间大致为 15 毫秒。当然，我们不必细究具体多久会强制释放 GIL，读者只需要明白，CPython 解释器会在一个“合理”的时间范围内释放 GIL 就可以了。 整体来说，每一个 Python 线程都是类似这样循环的封装，来看下面这段代码： for (;;) { if (--ticker \u003c 0) { ticker = check_interval; /* Give another thread a chance */ PyThread_release_lock(interpreter_lock); /* Other threads may run now */ PyThread_acquire_lock(interpreter_lock, 1); } bytecode = *next_instr++; switch (bytecode) { /* execute the next instruction ... */ } } 从这段代码中可以看出，每个 Python 线程都会先检查 ticker 计数。只有在 ticker 大于 0 的情况下，线程才会去执行自己的代码。 什么是原子性操作 原子操作(atomic operation)指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会切换到其他线程。 我们来看看python在这方面怎么做的。 首先看看a+=1编译之后的代码 其中 LOAD_NAME 将 a 当前的值加载进自己的运行栈； LOAD_CONST 将常量 1 加载到运行栈； INPLACE_ADD 对栈上两个操作数进行加法运算； STORE_NAME 将计算结果保存； 下面看看test.append('1') 对于a+=1来说，这个操作并不是原子性的，例如，某个线程test_1拿到了a的数据，进行自增之后，加到了2，此时正好时间片走完，这些正好在INPLACE_ADD操作之后切换线程到了test_2，test_2也是读取数据自增到二，如果两个线程都只运行一次自增，那么a的结果一定会是2。这就是并发操作产生的竞争态。 但是test.append('1')是原子性操作，为什么呢，因为在列表中，写入并不会存在竞争，不会存在脏数据的可能。 摘自： python有了GIL为什么还需要加锁？ python 源码分析 基本篇 Python GIL全局解释器锁详解（深度剖析） ","date":"2021-04-12","objectID":"/pythonbase/:0:0","tags":["python基础"],"title":"python基础学习","uri":"/pythonbase/"},{"categories":["学习记录","书面知识"],"content":"计算机网络学习笔记 ","date":"2021-01-10","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:0:0","tags":["计算机网络"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":["学习记录","书面知识"],"content":"计算机网络 ","date":"2021-01-10","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:1:0","tags":["计算机网络"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":["学习记录","书面知识"],"content":"基础知识 物理层 速率:连接在计算机网络主机在数字信道上传输数据的速率. 速率的k是1000进制,存储容量是1024进制. 带宽值网络中从一点到另一点的最高速率 单位时间内通过某个网络的数据量 时延带宽积:传播时延*带宽 代表某段链路现在有多少比特 往返时延RTT:从发送方发送数据开始,到发送方收到接收方的确认,总共经历的时延 利用率分信道利用率和网络利用率. 信道利用率:有数据通过的时间除以总时间 网络利用率:信道利用率加权平均值 为什么要分层 各层之间相互独立，高层只需要知道通过接口获得服务即可 灵活性好：各层之间都可以采用最合适的技术来实现。只要接口不变，不会产生影响 易于实现和标准化 协议是水平的,接口是上下的,上层可以使用下层的所有服务. ","date":"2021-01-10","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:1:1","tags":["计算机网络"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":["学习记录","书面知识"],"content":"链路层 OSI分层结构实体,协议,接口,服务 实体:第n层中的活动元素成为n层实体,同一层的实体叫对等实体. 协议:为进行网络中的对等实体数据交换而建立的规则,标准或约定称为网络协议. 接口:上层使用下层服务的入口. 服务:下层为相邻上层的功能调用 SDU服务数据单元:为完成用户所要求的功能而应传送的数据 PCI协议控制信息:控制协议操作的信息 PDU协议数据单元:对等层次之间传送的数据单位 码元是指用一个固定时长的信号波形(数字脉冲) 1个码元可以携带多个比特的信息量. 波特率:表示每秒传输n个码元 比特率:表示每秒传输n个比特 影响失真程度的因素: 码元传输速率 信号传输距离 噪声干扰 传输媒体质量 码间串扰:接收端收到的信号波形失去了码元之间清晰界限的现象. 奈氏准则:在理想低通条件下,为了避免码间串扰,极限码元传输速率为2W Baud,W是信道带宽,单位是hz 失真 带宽存在是因为有握手包,自识别,例如:300-3300的频率限制,实际上是先识别握手包(类似的概念),确定频率,再进行传输. 奈氏准则给出了码元传输速率的限制,但并没有对信息传输速率给出限制 香农定理在贷款首先且有噪声的信道中,为了不产生误差,信息的数据传输速率有上限值 2020/10/10起 信道:信号的传输没接.一般用来表示向某一个方向传递信息的介质,一条通信线路往往包含一条发送和一条接收信道. graph LR; A[数据]--编码--\u003eB[数字信号] G[数据]--调制--\u003eT[模拟信号] 数字数据--数字发送器--\u003eNS[数字信号`编码`] 数字数据--调制器--\u003eSS[模拟信号`调制`] 模拟数据--PCM编码器--\u003eNS1[数字信号`编码`] 模拟数据--放大器调制器--\u003e模拟信号'调制' 编码不按照定长时间周期是因为时间周期对于硬件来说并不是十分准确的,可能硬件之间有差异,若果一个为1.001s一个为0.999s那么隔定长时间之后会有很大的误差.相当于永久性的一个码元的错误.时间越长,错误越多 (1)非归零编码 (4)归零编码 (2)曼彻斯特编码 (5)反向不归零编码 (3)差分曼彻斯特编码 (6)4B/5B编码 若采用n个比特对帧编号: 滑动窗口长度应在 1$\\leq W_T \\leq 2^n -1$若尺寸过大.就无法区别新帧和旧内容. 点对点链路:两个相邻节点通过一个链路相连,没有第三者.应用:PPP协议,常用语广域网. 广播式跨不可以:所有主机共享通信介质. 应用:早期的总线以太网,无线局域网,常用于局域网. 典型拓扑结构:总线型,星型(逻辑总线型)\\ 1-坚持CSMA思想 若过一个主机要发送消息,那么它先监听信道. 空闲则直接传输,不必等待.忙则一直监听,直到空闲马上传输. 优点:只要媒体空闲,站点就马上发送,避免了媒体利用率的损失. 缺点:假如有两个或两个以上的站点有数据要发送,冲突不可避免. 非坚持CSMA思想 如果一个主机要发送消息,那么它先监听信道. 空闲则直接传输,不必等待. 忙则等待一个随机的时间之后在进行监听 优点:采用随机的重发延迟时间可以减少冲突发生的可能性. 缺点:可能存在都在等待过程,使得媒体仍可能处于空闲状态,媒体使用率降低. p-坚持CSMA思想 如果一个主机要发送消息,那么它先监听信道 空闲则以p概率直接传输,不必等待;概率1-p等待到下一个时间槽再传输. 优点:既能像非坚持算法减少冲突.又能像1-p坚持算法那样减少媒体空闲时间. 缺点:发生冲突后不坚持把数据发送完,造成了浪费. 各协议优缺点 1-坚持CSMA 非坚持CSMA p-坚持CSMA 信道空闲 马上发 马上发 p概率马上发,1-p概率等到下一个时隙在发送 信道忙 继续坚持监听 放弃监听,等一个随机时间再监听 放弃监听,等一个随机时间再监听 CSMA/CD协议 CS:载波侦听/监听,每一个站在发送数据之前以及发送数据时都要检测一个总线上是否有其他计算机在发送数据. MA:多点接入,表示许多计算机以多点介入的方式连接在一根总线上.(总线型网络) CD:碰撞监测(冲突检测),“边发送边监听\"适配器边发送数据边检测信道上信号电压的变化情况,以便判断自己在发送数据时其他站是否也在发送数据. 截断二进制指数规避算法. 确定基本退避(推迟)时间为争用期2$\\tau$. 定义参数K,他等于重传次数,但K不超过10,即k=mid[重传次数,10].当重传次数不超过10时,k等于重传次数,当重传次数大于10时,k就不再增大而一直等于10. 从离散的整数集合[0,1,$2^k-1$]中随机取一个数r,重传所需要退避的时间就是r倍的基本退避时间, 即2r$\\tau$ 当重传达到16次仍不能成功时,说明网络太拥挤,以为此帧永远无法正确发出,抛弃此帧并向高层报告出错. 为了防止帧太短导致发送完毕后才监测碰撞(因为已经发完了,没法停止).定义最小帧长.帧的传输时延至少要两倍于信号在总线中的传播时延. $\\frac{帧长}{数据传输速率}\\geq 2\\tau$ 最小帧长=总线传播时延$\\cdot$数据传输速率$\\cdot$2$\\cdot2\\tau\\cdot$数据传输速率 CSMA/CA协议 载波监听多点接入/碰撞避免CSMA/CA(carrier sense multiple access with collision avoidance) 为什么要有CSMA/cA: 发送数据前,先检测信道是否空闲. 空闲则发出RTS(request to send)RTS哪里跑发射端的地址,接收端的地址,下一份数据将持续发送的时间等信息;信道忙则等待. 接收端收到RTS后,将响应CTS(clear to send). 发送端收到CTS后,开始发送数据帧(同事预约信道;发送方告知其他站点自己要传多久的数据). 接收端收到数据帧后,江永CRC来检验数据是否正确,正确则相应ACK帧.发送方收到ACK就可以进行下一个数据帧的发送,若没有则一直重传至规定重发次数为止.(采用二进制指数规避算法来确定随机的推迟时间). 轮询访问介质访问控制. 信道划分介质访问控制(MAC multiple access control)协议: 基于多路复用技术划分资源. 网络负载重:共享信道效率高,且公平. 网络负载轻:共享信道效率低. 随机访问MAC协议: 用户根据意愿随机发送消息,发送消息时可独占信道带宽. 网络负载重:产生冲突开销. 网络负载轻:共享信道效率高,单个节点可利用信道全部带宽. 轮询访问MAC协议/轮流协议/轮转访问MAC协议: 既要不产生冲突,又要发送时占全部带宽. 问题:轮询开销、等待延迟、单点故障 令牌传递协议: 一个特殊格式的MAC控制帧,不含任何信息. 控制信道的使用,确保同一时刻只有一个结点独占信道.令牌环网无碰撞. 每个节点都可以在一定的时间内(令牌持有时间)获得发送数据的权利,并不是无限制地持有令牌. 问题: 1.令牌开销.2.等待延迟.3.单点故障 应用于令牌环网(物理星型拓扑,逻辑环形拓扑) 采用令牌传送方式的网络常用语负载较重,通信量较大的网络中 ","date":"2021-01-10","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:1:2","tags":["计算机网络"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":["学习记录","书面知识"],"content":"网络层 局域网(Local Area Network): 简称LAN.是指在某一区域内由多台计算机互联成的计算机使用广播信道. 虽然数据包发送时包含了完整的TCP/IP四层信息,但是IP地址只在网络间寻址才起作用,在同一个网络内,IP地址在发送端被转化为MAC地址进行寻址,而这种转化和交换的对应关系,依赖于ARP协议和MAC地址表. IP数据报首部 1.1 版本 占4位,通信双方的版本必须一致,如果是IPv4就同为4,如果IPv6就同为6 1.2 首部长度 单位是4B,最小是5,所以首部的长度最小应当是5*4B=20B 1.3 区分服务 占8位,用来获得更好的服务. 1.4 总长度 首部+数据,单位是1B,因此最大是65535 1.5 生存时间(TTL:Time TO Live) IP分组的保质期,每经过一个路由器就-1,变成0则丢弃. 1.6 协议 占8位,使得上层的主机知道应交给哪个处理过程 1.7 首部检验和 只检验首部 占16位，只检验数据报的首部，但不包括数据部分。 这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和(一些字段，如生存时间、标志、片偏移等都可能发生变化)。 不检验数据部分可减少计算的工作量。 为了进一步减少计算检验和的工作量，IP首部的检验和不采用复杂的CRC检验码而是采用以下算法： (1)在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段置零。 (2)用反码算术运算把所有16位字相加后，将得到的和的反码写入检验和字段， (3)接收方收到数据报后，将首部的所有16位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为0，于是就保留这个数据报，否则即认为出错，并将此数据报丢弃。 1.8 源地址 32位,ip地址 1.9 目的地址 32位,ip地址 1.10 可选字段 0~40B,用来支持排错、测量以及安全等措施 1.11 填充 填充0，让他变成4B的整数倍。 1.12 标识 同一数据报的分片使用同一标识。 1.13 标志 DF(Don’t Fragment): DF=1 禁止分片 DF=0 允许分片 MF(More Fragment): MF=1 后面\"还有分片” MF=0 代表最后一片/没有分片 1.14 片偏移 占13位，指出较长的分钟再分片后，某片在原分组中的相对位置。 也就是说，相对于用户数据字段的起点，该片从何处开始。 片偏移以8个字节为偏移单位。也就是说，每个分片的长度一定是8字节(64位)的整数倍。 例子：一数据报的总长度为3820字节，其数据部分为3800字节长(使用固定首部)，需要分片为长度不超过1420字节的数据报片。因固定首部长度为20字节，因此每个数据报片的数据部分长度不能超过1400字节。于是分成3个数据报片，其数据部分的长度分别分为1400,1400和1000字节。原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。 IP地址 A类地址 A类地址第1字节为网络地址（最高位固定是0），另外3个字节为主机地址。 A类地址范围：1.0.0.0 - 126.255.255.255，其中0和127作为特殊地址。 A类网络默认子网掩码为255.0.0.0，也可写作/8。 A类网络最大主机数量是256×256×256-2=166777214（减去1个主机位为0的网络地址和1个广播地址）。 B类地址 B类地址第1字节（最高位固定是10）和第2字节为网络地址，另外2个字节为主机地址。 B类地址范围：128.0.0.0 - 191.255.255.255。 B类网络默认子网掩码为255.255.0.0，也可写作/16。 B类网络最大主机数量256×256-2=65534。 C类地址 C类地址第1字节（最高位固定是110）、第2字节和第3个字节，另外1个字节为主机地址。 C类地址范围：192.0.0.0 - 223.255.255.255。　 C类网络默认子网掩码为255.255.255.0，也可写作/24。　 C类网络最大主机数量256-2=254。　 D类地址 D类地址不分网络地址和主机地址，它的第1个字节的最高位固定是1110。 D类地址用于组播（也称为多播）的地址，无子网掩码。 D类地址范围：224.0.0.0 - 239.255.255.255。 E类地址 E类地址也不分网络地址和主机地址，它的第1个字节的最高位固定是11110。 E类地址范围：240.0.0.0 - 255.255.255.255。 其中240.0.0.0-255.255.255.254作为保留地址，主要用于Internet试验和开发，255.255.255.255作为广播地址。 保留的特殊地址 以下这些特殊IP地址都是不能分配给主机用的地址： 网络地址转换NAT 子网 子网是为了分割网段而存在的。为了更加方便的分割网络，子网寻址也是一种分割B类甚至A类的方法。例如子网ID、主机ID。是为了更好的利用网络空间,例如一个A类地址,用不完,可以用子网掩码来进行分割. 子网掩码的存在是确认某些子网是否是同一个网段，通过按位与操作。 可变长度子网掩码是为了方便不同的主机数，可能不需要2^8,2^16,2^24的主机数，可能主机数是中间的数量级，所以会产生了可变子网掩码来进行确认同一网段的主机。CIDR则是更加细化例如192.168.1.0/24这种，就能够更加细分主机的不同网段。 子网掩码（Subnet Mask）又叫网络掩码、地址掩码，必须结合IP地址一起对应使用。 只有通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。 子网掩码和IP地址做“与”运算，分离出IP地址中的网络地址和主机地址，用于判断该IP地址是在本地网络上，还是在远程网络网上。 子网掩码还用于将网络进一步划分为若干子网，以避免主机过多而拥堵或过少而IP浪费。 CIDR IP地址/n 例1：192.168.1.100/24，其子网掩码表示为255.255.255.0，二进制表示为11111111.11111111.11111111.00000000 例2：172.16.198.12/20，其子网掩码表示为255.255.240.0，二进制表示为11111111.11111111.11110000.00000000 不难发现，例1中共有24个１，例2中共有20个１，所以n是这么来的。运营商ISP常用这样的方法给客户分配IP地址。 为什么要使用子网掩码 前面说道，子网掩码可以分离出IP地址中的网络地址和主机地址，那为什么要分离呢？因为两台主机要通信，首先要判断是否处于同一网段，即网络地址是否相同。如果相同，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地。 可以这么简单的理解：A主机要与B主机通信，A和B各自的IP地址与A主机的子网掩码进行And与运算，看得出的结果： 1、结果如果相同，则说明这两台主机是处于同一个网段，这样A可以通过ARP广播发现B的MAC地址，B也可以发现A的MAC地址来实现正常通信。 2、如果结果不同，ARP广播会在本地网关终结，这时候A会把发给B的数据包先发给本地网关，网关再根据B主机的IP地址来查询路由表，再将数据包继续传递转发，最终送达到目的地B。 计算机的网关（Gateway）就是到其他网段的出口，也就是路由器接口IP地址。路由器接口使用的IP地址可以是本网段中任何一个地址，不过通常使用该网段的第一个可用的地址或最后一个可用的地址，这是为了尽可能避免和本网段中的主机地址冲突。 在如下拓扑图示例中，A与B，C与D，都可以直接相互通信（都是属于各自同一网段，不用经过路由器），但是A与C，A与D，B与C，B与D它们之间不属于同一网段，所以它们通信是要经过本地网关，然后路由器根据对方IP地址，在路由表中查找恰好有匹配到对方IP地址的直连路由，于是从另一边网关接口转发出去实现互连。 ARP不同网段通信过程 1.假设主机A（135.24.25.23）第一次和同一网段内的主机B（135.24.25.32）通信 A封装好要发送的信息，在要写“收件地址”时， A会用子网掩码进行计算先判断B和A自己在不在同一个网段，这时候A成功知道了B和自己在同一个网段， 所以A会直接发一个ARP包，B在收到这个包之后会发现是给自己发的， 此时B也会封装一个ARP包来告诉A B自己的MAC地址， 这样A就知道了B的MAC地址，就可以完成报文的封装，发送给B 2.假设主机A（135.24.25.23）第一次和不同网段的主机C（135.24.52.123）通信： A封装好要发送的信息，在要写“收件地址”时， A会用子网掩码进行计算先判断B和A自己在不在同一个网段，这时候A知道了B和自己不在一个网段， 这时候，A知道该用网关把自己的数据传递给C，所以A会发送一个ARP包来获取网关的MAC地址， 网关收到ARP包后，把自己的MAC地址封装在ARP包中，发送给A， A封装报文，目标MAC地址写网关的MAC地址， 网关收到报文，发现是给自己发的，就开始解包，解开之后，发现是给另一个网段的主机发送的， 此时如果网管本身就是路由器就直接把数据报文发送给下一跳路由器，如果网关是普通的PC，就发送给路由器，由路由器发送给下一跳路由器，目标MAC写下一跳路由器的MAC地址， 历经千辛万苦，报文终于到达C的主机的路由器，路由器发送报文到C所在网段的网关， C网段的网关解包之后发现不是给自己，而是给自己网段内的C主机，就发送报给给C DHCP协议 应用层的协议,基","date":"2021-01-10","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:1:3","tags":["计算机网络"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":["学习记录","书面知识"],"content":"传输层 UDP协议 UDP概念 UDP是传输层的协议，功能即为在IP的数据报服务之上增加了最基本的服务：复用和分用以及差错检测。UDP提供不可靠服务，具有TCP所没有的优势。 UDP的特点 UDP无连接，时间上不存在建立连接需要的时延。空间上，TCP需要在端系统中维护连接状态，需要一定的开销。此连接装入包括接收和发送缓存，拥塞控制参数和序号与确认号的参数。UCP不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。 举个例子： DNS如果运行在TCP之上而不是UDP，那么DNS的速度将会慢很多。 HTTP使用TCP而不是UDP，是因为对于基于文本数据的Web网页来说，可靠性很重要。 同一种专用应用服务器在支持UDP时，一定能支持更多的活动客户机。 分组首部开销小，TCP首部20字节，UDP首部8字节。 UDP没有拥塞控制，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。某些实时应用要求以稳定的速度发送，能容 忍一些数据的丢失，但是不能允许有较大的时延（比如实时视频，直播等） UDP提供尽最大努力的交付，不保证可靠交付。所有维护传输可靠性的工作需要用户在应用层来完成。没有TCP的确认机制、重传机制。如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息 UDP是面向报文的，对应用层交下来的报文，添加首部后直接乡下交付为IP层，既不合并，也不拆分，保留这些报文的边界。对IP层交上来UDP用户数据报，在去除首部后就原封不动地交付给上层应用进程，报文不可分割，是UDP数据报处理的最小单位。 正是因为这样，UDP显得不够灵活，不能控制读写数据的次数和数量。比如我们要发送100个字节的报文，我们调用一次sendto函数就会发送100字节，对端也需要用recvfrom函数一次性接收100字节，不能使用循环每次获取10个字节，获取十次这样的做法。 UDP常用一次性传输比较少量数据的网络应用，如DNS,SNMP等，因为对于这些应用，若是采用TCP，为连接的创建，维护和拆除带来不小的开销。UDP也常用于多媒体应用（如IP电话，实时视频会议，流媒体等）数据的可靠传输对他们而言并不重要，TCP的拥塞控制会使他们有较大的延迟，也是不可容忍的 UDP的首部格式 UDP数据报分为首部和用户数据部分，整个UDP数据报作为IP数据报的数据部分封装在IP数据报中，UDP数据报文结构如图所示： UDP首部有8个字节，由4个字段构成，每个字段都是两个字节 源端口： 源端口号，需要对方回信时选用，不需要时全部置0. 目的端口：目的端口号，在终点交付报文的时候需要用到。 长度：UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部） 校验和：检测UDP数据报在传输中是否有错，有错则丢弃。 UDP校验 在计算校验和的时候，需要在UDP数据报之前增加12字节的伪首部，伪首部并不是UDP真正的首部。只是在计算校验和，临时添加在UDP数据报的前面，得到一个临时的UDP数据报。校验和就是按照这个临时的UDP数据报计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算校验和。这样的校验和，既检查了UDP数据报，又对IP数据报的源IP地址和目的IP地址进行了检验。 UDP校验和的计算方法和IP数据报首部校验和的计算方法相似，都使用二进制反码运算求和再取反，但不同的是：IP数据报的校验和之检验IP数据报和首部，但UDP的校验和是把首部和数据部分一起校验。 发送方，首先是把全零放入校验和字段并且添加伪首部，然后把UDP数据报看成是由许多16位的子串连接起来，若UDP数据报的数据部分不是偶数个字节，则要在数据部分末尾增加一个全零字节（此字节不发送），接下来就按照二进制反码计算出这些16位字的和。将此和的二进制反码写入校验和字段。在接收方，把收到得UDP数据报加上伪首部（如果不为偶数个字节，还需要补上全零字节）后，按二进制反码计算出这些16位字的和。当无差错时其结果全为1,。否则就表明有差错出现，接收方应该丢弃这个UDP数据报。 注意： 校验时，若UDP数据报部分的长度不是偶数个字节，则需要填入一个全0字节，但是次字节和伪首部一样，是不发送的。 如果UDP校验和校验出UDP数据报是错误的，可以丢弃，也可以交付上层，但是要附上错误报告，告诉上层这是错误的数据报。 通过伪首部，不仅可以检查源端口号，目的端口号和UDP用户数据报的数据部分，还可以检查IP数据报的源IP地址和目的地址。 这种差错检验的检错能力不强，但是简单，速度快 TCP协议 TCP概念 TCP(Transmission Control Protocol 传输控制协议)是一种面向连接(连接导向)的、可靠的、 基于IP的传输层协议。 TCP是工作在传输层的,IP在第三层——网络层 TCP首部报文结构 源端口和目的端口 各占2个字节，这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接。有时一个IP地址和一个端口号也称为socket（插口）。 序号(seq) 占4个字节，是本报文段所发送的数据项目组第一个字节的序号。在TCP传送的数据流中，每一个字节都有一个序号。例如，一报文段的序号为300，而且数据共100字节， 则下一个报文段的序号就是400；序号是32bit的无符号数，序号到达2^32-1后从0开始。 确认序号(ack) 占4字节，是期望收到对方下次发送的数据的第一个字节的序号，也就是期望收到的下一个报文段的首部中的序号；确认序号应该是上次已成功收到数据字节序号+1。 只有ACK标志为1时，确认序号才有效。 数据偏移 占4比特，表示数据开始的地方离TCP段的起始处有多远。实际上就是TCP段首部的长度。由于首部长度不固定，因此数据偏移字段是必要的。数据偏移以32位为长度单位， 也就是4个字节，因此TCP首部的最大长度是60个字节。即偏移最大为15个长度单位=1532位=154字节。 保留 6比特，供以后应用，现在置为0。 6个标志位比特 URG：当URG=1时，注解此报文应尽快传送，而不要按本来的列队次序来传送。与“紧急指针”字段共同应用，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号，使接管方可以知道紧急数据共有多长。 ACK：只有当ACK=1时，确认序号字段才有效； PSH：当PSH=1时，接收方应该尽快将本报文段立即传送给其应用层。 RST：当RST=1时，表示出现连接错误，必须释放连接，然后再重建传输连接。复位比特还用来拒绝一个不法的报文段或拒绝打开一个连接； SYN：SYN=1,ACK=0时表示请求建立一个连接，携带SYN标志的TCP报文段为同步报文段； FIN：发端完成发送任务。 窗口 TCP通过滑动窗口的概念来进行流量控制。设想在发送端发送数据的速度很快而接收端接收速度却很慢的情况下，为了保证数据不丢失，显然需要进行流量控制，协调好通信双方的工作节奏。所谓滑动窗口，可以理解成接收端所能提供的缓冲区大小。TCP利用一个滑动的窗口来告诉发送端对它所发送的数据能提供多大的缓 冲区。窗口大小为字节数起始于确认序号字段指明的值（这个值是接收端正期望接收的字节）。窗口大小是一个16bit字段，因而窗口大小最大为65535字节。 检验和 检验和覆盖了整个TCP报文段：TCP首部和数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。 紧急指针 只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP流量控制(滑动窗口协议) 在看这里,为了更好的理解,建议先了解TCP三次握手,四次挥手。 TCP流量控制主要是针对接收端的处理速度不如发送端发送速度快的问题，消除发送方使接收方缓存溢出的可能性。 TCP流量控制主要使用滑动窗口协议，滑动窗口是接受数据端使用的窗口大小，用来告诉发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量。控制的目的。这个窗口大小就是我们一次传输几个数据。对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。这样通过调整发送方窗口和接收方窗口的大小可以实现流量控制。 我们可以通过下图来分析: 发送方接收到了对方发来的报文 ack = 33, win = 10，知道对方收到了 33 号前的数据，现在期望接收 [33, 43) 号数据。那我们开始发送[33, 43) 号的数据。 [33, 43) 号的数据你是已经发送了,但接受方并没有接受到[36,37]数据。所以接收方发送回对报文段 A 的确认：ack = 35, win = 10。 发送方收到了 ack = 35, win = 10，对方期望接收 [35, 45) 号数据。那么发送方在发送[35, 45) 。 这里面需要思考一个问题？ 第一步发送了[33, 43),如果这次发送[35, 45),那中间重叠部分不是发送了两次,所以这里要思考: 是全部重新发送还是只发送接收端没有收到的数据,如果全部发送那么重复 发送的数据接收端怎么处理。这个下面快速重传会讲。 接收方接收到了报文段 [35, 41)，接收方发送：ack = 41, win = 10. （这是一个累积确认） 发送方收到了 ack = 41, win = 10，对方期望接收 [41, 51) 号数据。 ……. 这样一直传输数据,直到数据发送完成。这么一来就保证数据数据的可靠性,因为如果某数据没有获取到,那么ack永远不","date":"2021-01-10","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:1:4","tags":["计算机网络"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":["学习记录","书面知识"],"content":"网络层 DNS系统 域名分级 域名解析过程 递归查询和迭代查询 递归查询就是把查询的任务交给别的服务器,然后自己等待回应,但这种情况效率太低,消耗别的服务器的资源较多. 迭代查询是自己一个个问下一个域名服务器 他们的过程如图所示: FTP 传输文件的协议 SMTP协议 邮件协议 HTTP协议 HTTP协议是无状态的,但在实际中,网站经常需要记录用户的状态,因此有了cookie.(现在有很多技术能够存储在本地,方便网站安全读取这种数据.) Cookie是服务器发送到用户浏览器并保存到本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带Cookie数据，因此会带来额外的性能开销。 Session可以存储在服务器上的文件、数据库或者内存中。也可以将Session存储在Redis这种内存性数据库中，效率会更高。 使用Session维护用户登录状态的过程如下： 用户进行登录时，用户提交包含用户名和密码的表单，放入HTTP请求报文中 服务器验证该用户名和密码，如果正确则把用户信息存储到Redis中，它在Redis中的key称为SessionId 服务器端返回的响应报文的Set-Cookie首部字段包含了这个Session ID，客户端收到响应报文之后将该Cookie值存入浏览器中 客户端之后对同一服务器进行请求时会包含该Cookie值，服务器收到之后会提取出Session Id，从Redis中取出用户信息，继续之前的业务操作 应该注意Session Id的安全性问题，不能让他被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的SessionID值。此外，还需要经常重新生成SessionId。在对安全性要求极高的场景下，例如转账等操作，除了使用Session管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式 HTTP是采用TCP作为运输协议,但HTTP协议本身是无连接的.也就是TCP连接建立,就可以交换HTTP报文了. 两种连接过程如下所示: 报文结构: 状态码: 200 OK //客户端请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 ","date":"2021-01-10","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:1:5","tags":["计算机网络"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":["学习记录","书面知识"],"content":"摘自: IP数据报的首部 IP地址和子网划分学习笔记之《IP地址详解》 部分摘自ICMP协议详解 RIP详解 UDP协议的详细解析 【TCP协议】（1）—TCP协议详解 ","date":"2021-01-10","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/:1:6","tags":["计算机网络"],"title":"计算机网络","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"categories":["Java","高并发编程"],"content":"AtomicInteger: Java中的关键字,不用加锁也可以实现递增. 底层通过CAS(compare and swap)方法实现. CAS方法: 线程读取AtomicInteger的值,加1之后再比较新的值,如果新的值未改变,则更新新值,如果改变,则重复上述步骤. 解决线程读取过程中的ABA问题.0-\u003e2-\u003e0,线程是不可见这种改变的.但这种改变有很有意义, 解决方法:增加版本号,并且读取当前值时也读取版本号. synchronized:是Java中的关键字,是一种同步锁.它修饰的对象有以下集中: 修饰一个代码块 修饰一个方法 修改一个静态的方法 修改一个类 关于锁的信息是记录在对象的markword里面,markword占8个字节,锁的升级过程的信息都会存在markword中. 新建的对象为无锁态.当有线程调用时,会将锁变成偏向锁,当有线程争用这个锁时,就会升级为轻量级锁,轻量级锁(自旋锁)会一直自旋(消耗内存),也是同样的使用CAS操作,但是当这个自旋过程超过10次时,或者自旋线程超过CPU核数的一半,就会从用户态陷入内核态,交由操作系统,让他去控制wait,这样不消耗内存,让操作系统去调用它. 一个有趣的乱序证明: public class funnyDisturb { private static int x=0,a=0; private static int y=0,b=0; public static void main(String[] args) throws InterruptedException { int i=0; for(;;){ i++; x=0;y=0; a=0;b=0; Thread one = new Thread(new Runnable() { @Override public void run() { a=1; x=b; } }); Thread two = new Thread(new Runnable() { @Override public void run() { b=1; y=a; } }); one.start();two.start(); one.join();two.join(); if(x==0\u0026\u0026y==0){ System.out.println(\"第\"+i+\"次\"+x+\",\"+y); System.out.println(\"有趣的事情发生了,运行乱序被证明了\"); break; } } } } MESI Cache一致性协议 Modified Exclusive Shared Invalid 保持缓存的数据一致性协议.缓存行一般多用64字节. 有些无法被缓存的数据或者跨越多个缓存行的数据依然必须使用总线锁! ","date":"2021-01-07","objectID":"/licenseplate/:0:0","tags":["深入理解JAVA"],"title":"高并发编程理解","uri":"/licenseplate/"},{"categories":["学习记录","书面知识"],"content":"操作系统 ","date":"2021-01-06","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:0:0","tags":["操作系统"],"title":"操作系统","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["学习记录","书面知识"],"content":"操作系统的特征 ","date":"2021-01-06","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:0","tags":["操作系统"],"title":"操作系统","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["学习记录","书面知识"],"content":"并发 指两个事或多个事在同一时间间隔内发生。这种事件宏观上是同时发生的，但微观上是交替发生的(时分复用) 操作系统的并发性指计算机系统中同时存在着多个运行着的程序 让用户看起来觉得是并行的，实则不是，虽然现在多核cpu能够实现并行，但并发也是必不可少的 ","date":"2021-01-06","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:1","tags":["操作系统"],"title":"操作系统","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["学习记录","书面知识"],"content":"共享 共享就是资源共享，指多个并发执行的进程共同使用。 分互斥共享和同时共享。 互斥共享：一个时间段只能允许一个进程访问该资源 同时共享：一个时间段由多个进程“同时”对它们进行访问 如果失去并发性，则系统中只有一个程序正在运行，共享就没有了意义 如果失去共享性，则不同的进程无法访问同一个资源，并发就无法实现了。 ","date":"2021-01-06","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:2","tags":["操作系统"],"title":"操作系统","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["学习记录","书面知识"],"content":"虚拟 虚拟内存， ","date":"2021-01-06","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:3","tags":["操作系统"],"title":"操作系统","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["学习记录","书面知识"],"content":"异步 异步就是说，在多个程序并发执行下，由于资源是有限的，进程的执行不是一贯到底的，而是走走停停。 ","date":"2021-01-06","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:4","tags":["操作系统"],"title":"操作系统","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["算法导论"],"content":"动态规划 ","date":"2020-12-17","objectID":"/dynamicprogram/:1:0","tags":["动态规划","算法"],"title":"动态规划","uri":"/dynamicprogram/"},{"categories":["算法导论"],"content":"简介 动态规划(dynamic programming)与分治方法相似,都是通过组合子问题的解来求解原问题.但动态规划用来求解子问题重叠的情况.动态规划方法通常用来求解最优化问题(optimization problem). 钢条切割 给定一段长度为n英寸的钢条和一个价格表Pi,求切割钢条方案,使得销售收益Rn最大.注意,如果长条为n英寸的钢条的价格Pn足够大,最优解可能就是完全不需要切割. 长度i 1 2 3 4 5 6 7 8 9 10 价格Pi 1 5 8 9 10 17 17 20 24 30 动态规划,自顶向下,加入备忘机制,伪代码: let r[0...n] be a new array for i = 0 to n r[i]=-$\\Infty$ return MEMOIZED-CUT-ROD-AUX(p,n,r) MEMOIZED-CUT-ROD-AUX(p,n,r){ if(r[n]\u003e=0) return r[n] if(n==0) q=0 else(q==-$\\Infty$) for i=1 to n q=max(q,p[i]+MEMOIZED-CUT-ROD-AUX(p,n-i,r)) r[n]=q return q } 简单计算一下,该函数传递进去,先计算for i=1 to n,那么调用的就是参数为n-1的函数,反复调用至第1层,则r[1…n-1]都大于0了.成功被赋值.第一次循环就是查看将长度为n的长条分成1根1根的价格是多少.之后的每一次都会取最大值.该过程就把求长度为n的长条的最大价值是多少分成了长度为n-1的长条的最大价值是多少的递归解决方案,但该方案是有记录的,也就是说,当n=3的问题求解之后,求解n=4的问题就迎刃而解. BOTTOM-UP-CUT-ROD(p,n) let r[0,n] be a new array r[0]=0 for j=1 to n q=$\\Infty$ for i = 1 to j q= max(q,p[i]+r[j-i]) r[j]=q return r[n] 这个方法是自底向上的方法,就是从1-\u003en,先求解出小于x的最优解:例如求5的最优解,则在算法中,已经知道了4(含)以下的最优解是多少,那么只需要排列组合1-4,3-2就能求出5的最优解是多少了 动态规划问题较难,可能难以理解.只需要慢慢掌握即可. ","date":"2020-12-17","objectID":"/dynamicprogram/:1:1","tags":["动态规划","算法"],"title":"动态规划","uri":"/dynamicprogram/"},{"categories":["c语言","人工智能"],"content":"n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 N皇后问题棋盘 我们要做的就是把这种结果求出来,通过回朔法的方式把这个树建出来,在求解的过程中做剪枝,不用暴力破解这个答案,因为即使是8*8的所有解都是编译器难以接受的. 算法是我自己写的,没有优化.很久之前写的,更新博客的时候发现有这个就加进来了. #include\u003cstdio.h\u003e#include\u003cmalloc.h\u003e#define Lenth 8 typedef struct QueenNode{ char arr[Lenth*Lenth]; //定义棋盘 int jugde[Lenth*Lenth]; //判断棋盘是否可插入用 struct QueenNode *parents; int i; struct QueenNode *next; }QN; typedef struct QueueNode{ QN *smallQueenNode; struct QueueNode *next; }AQN; typedef struct Queue{ AQN *front; AQN *base; }Q; Q *queue; void equator(QN *p,QN *q){ //使得两个结点的arr和judge相等 int i; for(i=0;i\u003cLenth*Lenth;i++){ *(q-\u003earr+i)=*(p-\u003earr+i); *(q-\u003ejugde+i)=*(p-\u003ejugde+i); } } int Insert(QN *L,int target){ int i,lock1,lock2; int flag,number,floor,plant; flag=0; for(i=(L-\u003ei)*Lenth;i\u003c(L-\u003ei+1)*Lenth;i++){ if(*(L-\u003ejugde+i)==-1||*(L-\u003ejugde+i)==1)continue; if(*(L-\u003ejugde+i)==0\u0026\u0026(i%Lenth)==target){ *(L-\u003earr+i)='#'; //#为下在这个棋盘 *(L-\u003ejugde+i)=1; flag=1; //flag为信号，表示棋盘插入成功 break; } } if(flag==0)return 0; number=i%Lenth; //number为i所在行的第几位 floor=i/Lenth; //floor为插入点所在第几列 plant=i; //plant记录i在数组中的位置 lock1=lock2=0; //防止斜线不可插入越界 if(flag==1){ for(i=L-\u003ei*Lenth;i\u003cLenth*Lenth;i++){ if(i==plant)continue; if(i%Lenth==number){ //横行不可插入 *(L-\u003ejugde+i)=-1; } if(i/Lenth==floor){ //竖行不可插入 *(L-\u003ejugde+i)=-1; } if(i==plant+(i/Lenth-floor)*(Lenth+1)){ //右斜线不可插入 if(lock1==1)continue; if(i%Lenth==Lenth-1)lock1=1; *(L-\u003ejugde+i)=-1; } if(i==plant+(i/Lenth-floor)*(Lenth-1)){ //左斜线不可插入 if(lock2==1)continue; if(i%Lenth==0)lock2=1; *(L-\u003ejugde+i)=-1; } } } return 1; } int display(QN *L,int i){ //通过递归显示数组 int k; if(L-\u003eparents==NULL){ return 0; } else{ i=display(L-\u003eparents,i)+1; printf(\"step:%d\\n\",i); printf(\"************************************\\n\"); printf(\"\\t1\\t2\\t3\\t4\\t5\\t6\\n\"); for(k=0;k\u003cLenth*Lenth;k++){ printf(\"\\t%c\",*(L-\u003earr+k)); if(k%Lenth==Lenth-1)printf(\"\\n\"); } printf(\"************************************\\n\"); return i; } } QN *Delete(){ //从队列中删除第一个节点并且通过返回值返回 QN *L; L=queue-\u003efront-\u003enext-\u003esmallQueenNode; queue-\u003efront=queue-\u003efront-\u003enext; return L; } void queueInsert(QN *L){ //往队列里插入一个结点 AQN *T; T=(AQN *)malloc(sizeof(AQN)); T-\u003esmallQueenNode=(QN *)malloc(sizeof(QN)); equator(L,T-\u003esmallQueenNode); T-\u003esmallQueenNode-\u003ei=L-\u003ei; T-\u003esmallQueenNode-\u003eparents=L-\u003eparents; queue-\u003ebase-\u003enext=T; queue-\u003ebase=queue-\u003ebase-\u003enext; queue-\u003ebase-\u003enext=NULL; } void fenpei(QN *L){ L=(QN *)malloc(sizeof(QN)); } void Init(){ int i,j,k; QN *reselution,*reselution2,*t; QN *head,*g,p[Lenth],*s; queue=(Q *)malloc(sizeof(Q)); head=(QN *)malloc(sizeof(QN)); reselution=(QN *)malloc(sizeof(QN)); queue-\u003efront=queue-\u003ebase=(AQN *)malloc(sizeof(AQN)); queue-\u003efront-\u003esmallQueenNode=(QN *)malloc(sizeof(QN)); queue-\u003ebase-\u003esmallQueenNode=(QN *)malloc(sizeof(QN)); g=(QN *)malloc(sizeof(QN)); s=(QN *)malloc(sizeof(QN)); queue-\u003efront-\u003enext=NULL; queue-\u003ebase-\u003enext=NULL; reselution-\u003enext=NULL; head-\u003ei=0; head-\u003eparents=NULL; for(i=0;i\u003cLenth*Lenth;i++){ //初始化棋盘，空的为* *(head-\u003earr+i)='*'; *(head-\u003ejugde+i)=0; } queueInsert(head); reselution2=reselution-\u003enext; for(;queue-\u003efront-\u003enext!=NULL;){ //循环体当队列为空终止循环. s=Delete(); //读取队列队首结点 if(s-\u003ei==Lenth){ //如果到最后一行就做一个链表存储这些 s-\u003enext=reselution2; reselution-\u003enext=s; reselution2=reselution-\u003enext; } if(s-\u003ei\u003eLenth)break; //到了lenth就不做了，中断 for(k=0;k\u003cLenth;k++){ equator(s,g); g-\u003ei=s-\u003ei; g-\u003eparents=s-\u003eparents; g-\u003enext=s-\u003enext; if(!Insert(g,k))continue; fenpei(p+k); p[k].next=NULL; equator(g,p+k); p[k].i=g-\u003ei+1; p[k].parents=s; queueInsert(p+k); } } for(t=reselution-\u003enext,i=1;t!=NULL;t=t-\u003enext,i++){ printf(\"第%d种解题步骤是：\\n\",i); //依照链表输出 display(t,0); //通过parents指针，递归显示步骤 } } void main(){ Init(); } ","date":"2020-03-05","objectID":"/nqueen/:0:0","tags":["N皇后问题","人工智能"],"title":"N皇后问题","uri":"/nqueen/"},{"categories":["c语言","数据结构"],"content":"豁,这个就有意思了,这个是平衡二叉树,是在二叉排序树的基础上保持他很胖(可以想象越吃的多,越保持身体各方面维生素的均衡).能够增加查找的效率,但建立比较耗时. 因为严蔚敏老师那本教材没有源码,所以有了写出来的想法,本人有点愚钝,写的很慢,但过程很有意思,当然B和B+树和红黑树更难,但我只写出了这个代码,不深究上述树是因为我太菜了(I’m too vegetable!) 话不多说,介绍这个过程: 平衡二叉树定义:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。 平衡二叉树不平衡的情形： 把需要重新平衡的结点叫做α，由于任意两个结点最多只有两个儿子，因此高度不平衡时，α结点的两颗子树的高度相差2.容易看出，这种不平衡可能出现在下面4中情况中： 1.对α的左儿子的左子树进行一次插入 2.对α的左儿子的右子树进行一次插入 3.对α的右儿子的左子树进行一次插入 4.对α的右儿子的右子树进行一次插入 出现这种情况,就需要对这个插入的节点进行左右旋、右左旋、左左旋、右右旋来使得满足平衡二叉树的定义。 左左旋： 右左： #include\u003cstdio.h\u003e#include\u003cmalloc.h\u003e#include\u003cstring.h\u003e#define MAX 10 typedef struct BtreeNode{ char data[MAX]; int i; struct BtreeNode *Lchild,*Rchild; }BN; int bijiao(char a[MAX],char b[MAX]){ //新定义一个函数，有字符串长度的比较 if(strlen(a)\u003estrlen(b)) return 1; if(strlen(a)\u003cstrlen(b)) return -1; if(strlen(a)==strlen(b)){ int i; i=strcmp(a,b); return i; } } void biaoshi(BN *p){ //打印出这个二叉树的平衡因子 if(p==NULL) return; else{ biaoshi(p-\u003eLchild); printf(\"\\t%d\",p-\u003ei); biaoshi(p-\u003eRchild); } } int deep(BN *p){ //求该结点的深度 if(p==NULL) return 0; else{ int i,j; i=deep(p-\u003eLchild); j=deep(p-\u003eRchild); if(i\u003ej) return (i+1); else return (j+1); } } void pingheng(BN *p){ //使每个结点的元素p-\u003ei赋当前结构体的值 if(p==NULL){ return ; } else{ int i,j; pingheng(p-\u003eLchild); pingheng(p-\u003eRchild); i=deep(p-\u003eLchild); j=deep(p-\u003eRchild); p-\u003ei=i-j; } } BN *xunzhao(BN *p,int *i,int *c){ //寻找离插入结点最近的危机结点 if(p==NULL) return p; else{ BN *q; q=NULL; if(*c!=1) q=xunzhao(p-\u003eLchild,i,c); if(*c!=1) q=xunzhao(p-\u003eRchild,i,c); if(*c!=1){ if(p-\u003ei==2\u0026\u0026p-\u003eLchild-\u003ei==1){ *i=1; *c=1; return p; } if(p-\u003ei==2\u0026\u0026p-\u003eLchild-\u003ei==-1){ *i=3; *c=1; return p; } if(p-\u003ei==-2\u0026\u0026p-\u003eRchild-\u003ei==-1){ *i=2; *c=1; return p; } if(p-\u003ei==-2\u0026\u0026p-\u003eRchild-\u003ei==1){ *i=4; *c=1; return p; } } if(q==NULL) return p; else return q; } } BN *pinghenghua(BN *p,int i){ //在生成危机结点之后，将这个位置平衡化。 BN *s,*l; BN *m; BN *a,*j,*v; int b; int k; int g; int flag; g=0; a=j=p; k=0; flag=-1; m=xunzhao(p,\u0026k,\u0026g); //m为找到的危机结点，如果没有危机结点就会以k返回一个0值 while(a!=NULL\u0026\u0026b!=0){ b=bijiao(a-\u003edata,m-\u003edata); if(b\u003e0) {j=a;a=a-\u003eLchild;flag=1;} if(b\u003c0) {j=a;a=a-\u003eRchild;flag=2;} } if(k==1){ s=m-\u003eLchild; m-\u003eLchild=s-\u003eRchild; s-\u003eRchild=m; if(j==m) return s; if(flag==1) j-\u003eLchild=s; if(flag==2) j-\u003eRchild=s; return p; } if(k==2){ s=m-\u003eRchild; m-\u003eRchild=s-\u003eLchild; s-\u003eLchild=m; if(j==m) return s; if(flag==1) j-\u003eLchild=s; if(flag==2) j-\u003eRchild=s; return p; } if(k==3){ s=m-\u003eLchild; l=s-\u003eRchild; s-\u003eRchild=l-\u003eLchild; m-\u003eLchild=l-\u003eRchild; l-\u003eLchild=s; l-\u003eRchild=m; if(j==m) return l; if(flag==1) j-\u003eLchild=l; if(flag==2) j-\u003eRchild=l; return p; } if(k==4){ s=m-\u003eRchild; l=s-\u003eLchild; s-\u003eLchild=l-\u003eRchild; m-\u003eRchild=l-\u003eLchild; l-\u003eRchild=s; l-\u003eLchild=m; if(j==m) return l; if(flag==1) j-\u003eLchild=l; if(flag==2) j-\u003eRchild=l; return p; } return p; } BN *InsertBtree(BN *p,char key[MAX]){ BN *q,*s,*l,*n,*t,*o; o=t=n=q=s=p; int m; int i=0; while(s!=NULL){ m=bijiao(s-\u003edata,key); if(m\u003e0) {q=s;s=s-\u003eLchild;} if(m\u003c0){q=s;s=s-\u003eRchild;} if(m==0){ q=s;s=s-\u003eLchild; } i++; } l=(BN *)malloc(sizeof(BN)); l-\u003eLchild=NULL; l-\u003eRchild=NULL; strcpy(l-\u003edata,key); if(m\u003e0){ q-\u003eLchild=l; } else{ q-\u003eRchild=l; } pingheng(p); p=pinghenghua(p,i); pingheng(p); return p; } BN *InitBtree(){ char x[MAX]; int flag; BN *p,*head; head=NULL; scanf(\"%s\",\u0026x); flag=0; while(x[0]!='$'){ if(flag==0){ p=(BN *)malloc(sizeof(BN)); p-\u003eLchild=NULL; p-\u003eRchild=NULL; head=p; strcpy(p-\u003edata,x); flag=1; pingheng(head); } else{ head=InsertBtree(head,x); } scanf(\"%s\",\u0026x); } return head; } void show(BN *p){ if(p==NULL) return ; else{ show(p-\u003eLchild); printf(\"%s\\t\",p-\u003edata); show(p-\u003eRchild); } } BN *Dxunzhao(BN *p,int *i,int *c){ //寻找离插入结点最近的危机结点 if(p==NULL) return p; else{ BN *q; q=NULL; if(*c!=1) q=Dxunzhao(p-\u003eLchild,i,c); if(*c!=1) q=Dxunzhao(p-\u003eRchild,i,c); if(*c!=1){ if((p-\u003ei==2\u0026\u0026p-\u003eLchild-\u003ei==1)){ *i=1; *c=1; return p; } if((p-\u003ei==2\u0026\u0026p-\u003eLchild-\u003ei==-1)||(p-\u003ei==2\u0026\u0026p-\u003eLchild-\u003ei==0)){ *i=3; *c=1; return p; } if(p-\u003ei==-2\u0026\u0026p-\u003eRchild-\u003ei==-1){ *i=2; *c=1; return p; } if((p-\u003ei==-2\u0026\u0026p-\u003eRchild-\u003ei==1)","date":"2020-03-05","objectID":"/binarybalancedtree/:0:0","tags":["平衡二叉树","数据结构"],"title":"AVL平衡树","uri":"/binarybalancedtree/"},{"categories":["c语言","数据结构"],"content":" #include\u003cstdio.h\u003e#define N 1100 int max(int a,int b){ if(a\u003cb){ return b; } else{ return a; } } int min(int a,int b){ if(a\u003cb){ return a; } else{ return b; } } int main(){ char arr[N]; char ass[N]; int a[N]; int b[N]; int sum[N+1]; int s; int q; int x,y,d,f,o,j,k; int l,m,n; scanf(\"%d\",\u0026n) ; sum[0]=-199; for(int i=0 ; i\u003cn ; i++ ) { int g=0; scanf(\"%s\",\u0026arr); scanf(\"%s\",\u0026ass); for(d=0;d\u003cN;d++){ x=arr[d]; if(x==0){ break; } } for(f=0;f\u003cN;f++){ y=ass[f]; if(y==0){ break; } } for(o=0;o\u003cd;o++){ s=arr[o]; if(s\u003c=57\u0026\u0026s\u003e=48){ a[o]=arr[o]-48; } } for(j=0;j\u003cf;j++){ q=ass[j]; if(q\u003c=57\u0026\u0026q\u003e=48){ b[j]=ass[j]-48; } } x=max(d,f); y=min(d,f); for(k=x;k\u003e=0;k--){ if(k==0\u0026\u0026g==1){ sum[k]=1; } else{ if(k\u003ex-y){ if(d\u003cf){ sum[k]=a[y+k-1-x]+b[k-1]+g; } else{ sum[k]=a[k-1]+b[y+k-1-x]+g; } g=0; if(sum[k]\u003e=10){ g=1; sum[k]=sum[k]-10; } } else{ if(d\u003ef){ sum[k]=a[k-1]+g; g=0; } else{ sum[k]=b[k-1]+g; g=0; } } } } for(l=0;l\u003c=x;l++){ if(sum[0]==0){ sum[0]=-199;} if(sum[l]\u003c10\u0026\u0026sum[l]\u003e=0){ printf(\"%d\",sum[l]); } } printf(\"\\n\"); } return 0; } ","date":"2020-03-05","objectID":"/linearbinarytree/:0:0","tags":["不知道做的啥玩意,有点久远了","数据结构"],"title":"不知道做的啥玩意,有点久远了","uri":"/linearbinarytree/"},{"categories":["c语言","数据结构"],"content":"二叉排序树: 一棵空树，或者是具有下列性质的二叉树： （1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值； （2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值； （3）左、右子树也分别为二叉排序树； （4）没有键值相等的结点。 #include\u003cstdio.h\u003e#include\u003cmalloc.h\u003e#include\u003cstring.h\u003e#define MAX 10 typedef struct BtreeNode{ char data[MAX]; int i; struct BtreeNode *lchild,*rchild; }BN; int bijiao(char a[MAX],char b[MAX]){ if(strlen(a)\u003estrlen(b)) return 1; if(strlen(a)\u003cstrlen(b)) return -1; if(strlen(a)==strlen(b)){ int i; i=strcmp(a,b); return i; } } void InsertBtree(BN *p,char key[MAX]){ BN *q,*s,*l; q=s=p; int m; while(s!=NULL){ m=bijiao(s-\u003edata,key); if(m\u003e0) {q=s;s=s-\u003elchild;} else{ q=s;s=s-\u003erchild; } } l=(BN *)malloc(sizeof(BN)); l-\u003elchild=NULL; l-\u003erchild=NULL; strcpy(l-\u003edata,key); if(m\u003e0){ q-\u003elchild=l; } else{ q-\u003erchild=l; } } BN *InitBtree(){ char x[MAX]; int flag; BN *p,*head; head=NULL; scanf(\"%s\",\u0026x); flag=0; while(x[0]!='$'){ if(flag==0){ p=(BN *)malloc(sizeof(BN)); p-\u003elchild=NULL; p-\u003erchild=NULL; head=p; strcpy(p-\u003edata,x); flag=1; } else{ InsertBtree(head,x); } scanf(\"%s\",\u0026x); } return p; } void show(BN *p) { if (p!=NULL) { show(p-\u003elchild); printf(\"%s\\t\",p-\u003edata); show(p-\u003erchild ); } } void Delete(BN *p,char x[MAX]){ BN *s,*q,*n; int m; q=s=p; m=bijiao(p-\u003edata,x); if(m==0){ p-\u003elchild=NULL; p-\u003erchild=NULL; return; } while(s!=NULL){ m=bijiao(s-\u003edata,x); if(m\u003e0) {q=s;s=s-\u003elchild;} if(m\u003c0) {q=s;s=s-\u003erchild;} if(m==0) break; } if(s!=NULL){ if(s-\u003elchild!=NULL){ n=s-\u003elchild; while(n-\u003erchild!=NULL) n=n-\u003erchild; if(q-\u003elchild==s){ n-\u003erchild=s-\u003erchild; q-\u003elchild=s-\u003elchild; } else{ n-\u003erchild=s-\u003erchild; q-\u003erchild=s-\u003elchild; } } else{ if(q-\u003elchild==s) q-\u003elchild=s-\u003erchild; else q-\u003erchild=s-\u003erchild; } if(s-\u003elchild==NULL\u0026\u0026s-\u003erchild==NULL){ if(q-\u003elchild==s) q-\u003elchild=NULL; if(q-\u003erchild==s) q-\u003erchild=NULL; } } else{ printf(\"没有这个数据\"); } } void main(){ BN *p; BN *l; char x[MAX]; p=InitBtree(); show(p); scanf(\"%s\",\u0026x); Delete(p,x); show(p); } } ","date":"2020-03-05","objectID":"/binarysortingtree/:0:0","tags":["二叉排序树","数据结构"],"title":"二叉排序树","uri":"/binarysortingtree/"},{"categories":["c语言","数据结构"],"content":" #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003etypedef char AdjType; typedef struct Btree{ AdjType date; struct Btree *lchild,*rchild; }btree; int count; int i; btree *Init(){ btree *p; char x; scanf(\"%c\",\u0026x);getchar(); if(x ==' '){ p=NULL; } else{ p=(btree *)malloc(sizeof(btree)); p-\u003edate=x; printf(\"\\n\\t\\t\\t请输入一个非#的字符,当前访问到%c的左子女\",p-\u003edate); p-\u003elchild=Init(); printf(\"\\n\\t\\t\\t请输入一个非#的字符,当前访问到%c的右子女\",p-\u003edate); p-\u003erchild=Init(); } return p; } void xianxu(btree *p){ if(p==NULL) return; printf(\"%c\",p-\u003edate); xianxu(p-\u003elchild); xianxu(p-\u003erchild); } void zhongxu(btree *p){ if(p==NULL) return; zhongxu(p-\u003elchild); printf(\"%c\",p-\u003edate); zhongxu(p-\u003erchild); } void houxu(btree *p){ if(p==NULL) return; houxu(p-\u003elchild); houxu(p-\u003erchild); printf(\"%c\",p-\u003edate); } int yezi(btree *p){ if(p!=NULL){ if(p-\u003elchild==NULL\u0026\u0026p-\u003erchild==NULL){ count++; return count; } else{ yezi(p-\u003elchild); yezi(p-\u003erchild); } } else{ return i; } } int bNodecount(btree *p){ if(p!=NULL){ count++; bNodecount(p-\u003elchild); bNodecount(p-\u003erchild); return count; } } int Treedeep(btree *p){ int ldeep,rdeep; if(p==NULL) return 0; ldeep=Treedeep(p-\u003elchild); rdeep=Treedeep(p-\u003erchild); if(ldeep\u003erdeep) return (ldeep+1); else return (rdeep+1); } void main(){ int i; btree *p; char choice; choice='1'; while(choice!='0'){ count=0; printf(\"\\n\\n\\n\\n\"); printf(\"\\t\\t\\t-二叉树的基本运算--\\n\"); printf(\"\\n\\t\\t\\t************************************\"); printf(\"\\n\\t\\t\\t* 1-------建 二 叉 树 *\"); printf(\"\\n\\t\\t\\t* 2-------先 序 遍 历 *\"); printf(\"\\n\\t\\t\\t* 3-------中 序 遍 历 *\"); printf(\"\\n\\t\\t\\t* 4-------后 序 遍 历 *\"); printf(\"\\n\\t\\t\\t* 5-------统计 叶子数 *\"); printf(\"\\n\\t\\t\\t* 6-------统计 结点数 *\"); printf(\"\\n\\t\\t\\t* 7-------求二叉树深度 *\"); printf(\"\\n\\t\\t\\t* 0-------退 出 *\"); printf(\"\\n\\t\\t\\t************************************\\n\"); printf(\"\\t\\t\\t请选择菜单号(0--7): \"); scanf(\"%c\",\u0026choice);getchar(); if(choice=='1'){ p=Init(); } if(choice=='2'){ xianxu(p); } if(choice=='3') zhongxu(p); if(choice=='4') houxu(p); if(choice=='5'){ i=0; i=yezi(p); printf(\"%d\",i); } if(choice=='6'){ i=0; i=bNodecount(p); printf(\"%d\",i); } if(choice=='7'){ i=0; i=Treedeep(p); printf(\"%d\",i); } } } ","date":"2020-03-05","objectID":"/binarytree/:0:0","tags":["二叉树","数据结构"],"title":"二叉树","uri":"/binarytree/"},{"categories":["c语言","数据结构"],"content":"二叉树转森林,左子树为孩子节点,右子树为孩子兄弟节点 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cmalloc.h\u003etypedef int AdjType; typedef struct QNode{ AdjType i; AdjType date; struct QNode *next; }Q; typedef struct Sqlist{ Q *front; Q *rear; }S; void Init(S* p){ p-\u003erear=p-\u003efront=(Q *)malloc(sizeof( Q )); p-\u003erear-\u003enext=NULL; printf(\"\\n\\t\\t\\t银行计划初始化成功!\"); } void insert(S *p,int i,int j){ Q *q; printf(\"\\n\\t\\t\\t第%d位客户进入了银行他要用的时间是%d\\t\",i,j); q=(Q *)malloc(sizeof(Q)); q-\u003edate=j; p-\u003erear-\u003enext=q; p-\u003erear=q; q-\u003ei=i; p-\u003erear-\u003enext=NULL; } void Delete(S *p,int i){ Q *q; if(p-\u003efront==p-\u003erear) return; q=p-\u003efront-\u003enext; if(q-\u003edate==0\u0026\u0026i==1){ p-\u003efront=p-\u003efront-\u003enext; printf(\"\\n\\t\\t\\t第%d客户已经离开了银行\\n\",q-\u003ei); } } int fanhui(S *p){ int i; Q *q; q=p-\u003efront; i=0; if(q==p-\u003erear){ return 0; } while(q!=p-\u003erear){ i++; return i; } } void jianyi(S *p){ Q *q; if(p-\u003efront==p-\u003erear) return ; q=p-\u003efront-\u003enext; if(q-\u003edate\u003e0) q-\u003edate=q-\u003edate-1; } int shijianhe(S *p){ int j; Q *q; j=0; q=p-\u003efront; do{ q=q-\u003enext; j=q-\u003edate+j; }while(q!=p-\u003erear); return j; } int min(int a,int b){ if(a\u003eb) return b; else return a; } void xianshi(S *p,int i){ Q *q; if(p-\u003efront==p-\u003erear) return ; q=p-\u003efront-\u003enext; printf(\"\\t第%d位客户在%d窗口,数值是%d\",q-\u003ei,i+1,q-\u003edate); } void main(){ S a[4]; int visited[4]={0}; int b[4]; int i,k,l,s; int flag; int j; int x; x=1; for(k=0;k\u003c=3;k++){ Init(\u0026a[k]); } for(i=1;x!=0;i++){ if(x==1){ s=31; for(k=0;k\u003c4;k++){ b[k]=0; } j=rand()%30+1; flag=0; for(k=0;k\u003c4;k++){ b[k]=fanhui(\u0026a[k]); if(fanhui(\u0026a[k])==0){ insert(\u0026a[k],i,j); visited[k]=1; break; } b[k]=fanhui(\u0026a[k]); } if(b[1]\u0026\u0026b[2]\u0026\u0026b[0]\u0026\u0026b[3]){ for(k=0;k\u003c4;k++){ s=min(shijianhe(\u0026a[k]),s); } for(k=0;k\u003c4;k++){ if(s==shijianhe(\u0026a[k])){ insert(\u0026a[k],i,j); visited[k]=1; break; } } } } for(k=0;k\u003c4;k++){ printf(\"\\n\\t\\t\"); xianshi(\u0026a[k],k); } for(k=0;k\u003c4;k++){ jianyi(\u0026a[k]); } for(k=0;k\u003c4;k++){ Delete(\u0026a[k],visited[k]); } printf(\"\\n\\t\\t\\t请输入控制字0结束，1继续产生随机数，2不产生随机数\"); scanf(\"%d\",\u0026x); } printf(\"\\n\\t\\t\\t银行下班了\"); } ","date":"2020-03-05","objectID":"/binarytreetofrost/:0:0","tags":["二叉树转森林","数据结构"],"title":"二叉树转森林","uri":"/binarytreetofrost/"},{"categories":["c语言","数据结构"],"content":"哈弗曼树:给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 在计算机数据处理中，哈夫曼编码使用变长编码表对源符号（如文件中的一个字母）进行编码，其中变长编码表是通过一种评估来源符号出现机率的方法得到的，出现机率高的字母使用较短的编码，反之出现机率低的则使用较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。 #include\u003cstdio.h\u003e#include\u003cmalloc.h\u003e#include\u003cstring.h\u003e#define MAX 10 #define M 100 typedef struct HTNode{ char data[MAX]; int i; struct HTNode *Lchild,*Rchild; }Huffman; typedef struct ListNode{ int data; struct ListNode *next; }LN; LN *head; void INit(){ LN *q,*p; int x; head=(LN *)malloc(sizeof(LN)); p=head; head-\u003enext=NULL; scanf(\"%d\",\u0026x);getchar(); while(x!=0){ q=(LN *)malloc(sizeof(LN)); q-\u003enext=NULL; q-\u003edata=x; p-\u003enext=q; p=q; scanf(\"%d\",\u0026x);getchar(); } } void Insert(int x){ LN *q,*s; q=head; while(q-\u003enext!=NULL){ q=q-\u003enext; } s=(LN *)malloc(sizeof(LN)); q-\u003enext=s; s-\u003edata=x; s-\u003enext=NULL; } void Delete(LN *p,int i){ LN *q,*s; q=s=head; if(s-\u003enext==NULL) return ; while(s-\u003edata!=i\u0026\u0026s!=NULL){ q=s; s=s-\u003enext; } if(s!=NULL) q-\u003enext=s-\u003enext; } int min(LN *p){ LN *q,*s; int i; q=head; i=q-\u003enext-\u003edata; while(q-\u003enext!=NULL){ q=q-\u003enext; if(q-\u003edata\u003c=i){ i=q-\u003edata; printf(\"{%d}\",i); } } return i; } Huffman *InitHuffman( ){ Huffman *L,*R,*p,*s,*f,*t,*z[M]; LN *q; int l,r,i,j,flag,k; flag=-1; i=k=0; j=0; INit( ); q=head; l=min(head); z[i]=(Huffman *)malloc(sizeof(Huffman)); s=(Huffman *)malloc(sizeof(Huffman)); z[i]-\u003eLchild=z[i]-\u003eRchild=s-\u003eLchild=s-\u003eRchild=NULL; z[i]-\u003ei=0; s-\u003ei=l; Delete(head,l); r=min(head); Delete(head,r); while(1){ for(j=0;j\u003c=i;j++){ if(z[j]-\u003ei==l||z[j]-\u003ei==r){ flag=1; printf(\"flag==1\"); break; } } for(k=0;k\u003c=i;k++){ if(k==j) continue; if(z[k]-\u003ei==l||z[k]-\u003ei==r){ flag=2; printf(\"flag==2\"); break; } } if(flag==2){ f=(Huffman *)malloc(sizeof(Huffman)); f-\u003eLchild=NULL; f-\u003eRchild=NULL; f-\u003eLchild=z[k]; f-\u003eRchild=z[j]; f-\u003ei=f-\u003eLchild-\u003ei+f-\u003eRchild-\u003ei; t=z[k]=f; flag=0; } else{ if(flag==1){ f=(Huffman *)malloc(sizeof(Huffman)); f-\u003eLchild=NULL; f-\u003eRchild=NULL; f-\u003eLchild=p; f-\u003eRchild=z[j]; f-\u003ei=f-\u003eLchild-\u003ei+f-\u003eRchild-\u003ei; t=p=f; flag=0; } else{ if(s-\u003ei==l||s-\u003ei==r){ p=(Huffman *)malloc(sizeof(Huffman)); p-\u003eRchild=NULL; printf(\"%d\",s-\u003ei); p-\u003eLchild=s; p-\u003eRchild=(Huffman *)malloc(sizeof(Huffman)); p-\u003eRchild-\u003eLchild=p-\u003eRchild-\u003eRchild=NULL; if(s-\u003ei==l) p-\u003eRchild-\u003ei=r; else p-\u003eRchild-\u003ei=l; p-\u003ei=p-\u003eLchild-\u003ei+p-\u003eRchild-\u003ei; t=s=p; } else{ i++; R=(Huffman *)malloc(sizeof(Huffman)); L=(Huffman *)malloc(sizeof(Huffman)); z[i]=(Huffman *)malloc(sizeof(Huffman)); R-\u003eLchild=R-\u003eRchild=L-\u003eLchild=L-\u003eRchild=z[i]-\u003eLchild=z[i]-\u003eRchild=NULL; L-\u003ei=l; R-\u003ei=r; z[i]-\u003eLchild=L; z[i]-\u003eRchild=R; z[i]-\u003ei=z[i]-\u003eLchild-\u003ei+z[i]-\u003eRchild-\u003ei; t=z[i]; } } } Insert(t-\u003ei); if(head-\u003enext-\u003enext!=NULL){ l=min(head); Delete(head,l); r=min(head); Delete(head,r); } else{ break; } } return p; } void xianxu(Huffman *p){ if(p==NULL) return ; else{ printf(\"%d\\t\",p-\u003ei); xianxu(p-\u003eLchild); xianxu(p-\u003eRchild); } } void main(){ Huffman *p; p=InitHuffman(); xianxu(p); } ","date":"2020-03-05","objectID":"/huffmantree/:0:0","tags":["哈弗曼树","数据结构"],"title":"哈弗曼树","uri":"/huffmantree/"},{"categories":["c语言","数据结构"],"content":"图! 这个就牛逼了,增删改查.看代码 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include\u003cmalloc.h\u003e #define MAX 20 /* 图的最多顶点数*/#define INF 65535 /*定义大于所有权值的一个数*/typedef enum {DGN,UDGN} GraphKind; /*DGN包括有向图和有向网，UDGN包括无向图和无向网*/ typedef char VertexType; /* 图的顶点类型 */ typedef int AdjType; /* 图的边（或弧）的类型，如果是网，则权值非负 */ typedef char zifu; typedef int zheng; typedef struct list{ VertexType date; struct list *next; }lqlist; typedef struct Queuelist{ zheng date; /*队列的数据类型*/ struct Queuelist *next; }QNode, *Queue; typedef struct queuelist{ Queue front; Queue rear; }S,*PQueue; struct { VertexType vex; AdjType lowcost; }closeedge[MAX]; typedef struct { VertexType vexs[MAX+1]; /* 表示的顶点的一维向量 */ AdjType edges[MAX+1][MAX+1]; /* 表示图的边（或弧）的邻接矩阵，对于无权图用1或0表示顶点是否相邻，对于带权图，则为权值类型 */ int n,e; /* n表示当前顶点数 e表示当前的边数（弧数） */ }MGraph; /*为了避免元素的位序与C语言数组的表示之间的错位，不使用C语言中数组的零元素*/ void InitQueue(PQueue p){ p-\u003efront=p-\u003erear=(Queue)malloc(sizeof(QNode)); p-\u003efront-\u003enext=NULL; } void InsertQueue(PQueue p,zheng i){ Queue q; q=(Queue)malloc(sizeof(QNode)); q-\u003edate=i; q-\u003enext=NULL; if(p-\u003erear==NULL){ p-\u003efront=q; p-\u003erear=q; } else{ p-\u003erear-\u003enext=q; p-\u003erear=q; } } int DeleteQueue(PQueue p){ QNode *q; q=p-\u003efront; if(p-\u003efront==p-\u003erear){ p-\u003efront=NULL; p-\u003erear=NULL; } else{ p-\u003efront=p-\u003efront-\u003enext; free(q); } return p-\u003efront-\u003edate; } int panduan(PQueue p){ if(p-\u003efront==p-\u003erear){ return 1; } else{ return 0; } } void CreateGN(MGraph* G,GraphKind gk) /*构造图*/ { int i,j,k; AdjType w; printf(\"\\n\\t\\t请输入图的顶点数和边数(格式为：顶点数，边数)\\n\\t\\t\"); scanf(\"%d,%d\",\u0026(G-\u003en),\u0026(G-\u003ee));getchar(); /*输入图的顶点数和边数*/ for(i=1;i\u003c=G-\u003en;i++) for(j=1;j\u003c=G-\u003en;j++) G-\u003eedges[i][j]=INF; /*邻接矩阵的初始化,用INF表示边或弧的不存在*/ printf(\"\\t\\t请输入各顶点的值（该值对应的序号为它输入时的次序）：\\n\\t\\t\"); for(i=1;i\u003c=G-\u003en;i++) { scanf(\"%c\",\u0026(G-\u003evexs[i]));getchar();printf(\"\\t\\t\"); } /*构造顶点向量*/ printf(\"请输入边信息，如果不是网，则用1表示,否则输入权值\\n\"); printf(\"\\t\\t如果是网，则输入权值!\\n\"); printf(\"\\t\\t输入格式为：端点1的序号，端点2的序号，1或权值\\n\\t\\t\"); for(k=1;k\u003c=G-\u003ee;k++) { scanf(\"%d,%d,%d\",\u0026i,\u0026j,\u0026w); /* i和j分别表示两个顶点在一维向量的位置，w表示边（或弧）的值， 如果两个顶点之间没有边，则权值w为一特定的预先给定的值*/ getchar(); printf(\"\\t\\t\"); G-\u003eedges[i][j]=w; if (gk==2) G-\u003eedges[j][i]=w; } /*构造邻接矩阵*/ printf(\"\\n\\t\\t输入的各个顶点为： \"); for(i=1;i\u003c=G-\u003en;i++) printf(\"%c\\t\",G-\u003evexs[i]); printf(\"\\n\\t\\t输入的邻接矩阵为： \\n\"); for(i=1;i\u003c=G-\u003en;i++) { printf(\"\\n\\t\\t\"); for(j=1;j\u003c=G-\u003en;j++) printf(\"%d\\t\",G-\u003eedges[i][j]); } } int FirstAdjVertex(MGraph* G,int i) /*返回图(网)G的第i个顶点的第一个邻接顶点的值*/ { int j; for(j=1;j\u003c=G-\u003en;j++) if (j!=i \u0026\u0026 G-\u003eedges[i][j]!=INF) break; if (j==G-\u003en+1) return 0; else return j; } int NextAdjVertex(MGraph* G,int i,int j) /*已知图(网)G的第j个顶点是第i个顶点的邻接顶点，求第i个顶点的相对于第j个顶点的下一个邻接顶点*/ { int k; for(k=1;k\u003c=G-\u003en;k++) { if (k!=i \u0026\u0026 k!=j \u0026\u0026 G-\u003eedges[i][k]!=INF) break; } if (k==G-\u003en+1){ return 0; } else{ return k; } } void DFSM(MGraph* G,int i,int* tag) /*采用数组表示法表示的无向图的从第i个顶点开始的深度优先搜索遍历*/ { int j; printf(\"%c\\t\",G-\u003evexs[i]); /*采用打印函数访问每个结点*/ tag[i]=1; for(j=1;j\u003c=G-\u003en;j++) if ((!tag[j]) \u0026\u0026 G-\u003eedges[i][j]!=INF) DFSM(G,j,tag); /*递归调用*/ } void BFSM(MGraph* G,int i,int* tag) /*采用数组表示法表示的无向图的从第i 个顶点开始的广度优先搜索遍历*/ { S p; int k,j; int u; InitQueue(\u0026p); InsertQueue(\u0026p,i); tag[i]=1; u=i; printf(\"\\n\\t\\t广度优先遍历搜索的结果是\\n\\t\"); while(!panduan(\u0026p)){ u=DeleteQueue(\u0026p); printf(\"\\t%c\",G-\u003evexs[u]); for(j=1;j\u003c=G-\u003en;j++){ if(!tag[j]\u0026\u0026G-\u003eedges[u][j]!=INF){ tag[j]=1; InsertQueue(\u0026p,j); } } } } void Prim(MGraph* G, int i) { /*用Prim方法建立有n个顶点的邻接矩阵存储结构的网gm的最小生成树*/ /*从序号为1的顶点出发；建立的最小生成树存于数组closevertex中*/ int mincost; int j,k,m; int vexnum; vexnum=G-\u003en; for (j=1;j\u003c=G-\u003en;j++) /*辅助数组初始化*/ if (j!=i) { closeedge[j].vex=G-\u003evexs[i]; closeedge[j].lowcost=G-\u003eedges[i][j]; } closeedge[i].lowcost=0; /*从序号为i的顶点出发生成最小生成树*/ vexnum--; while(vexnum!=0) /*寻找当前最小权值的边的顶点*/ { mincost=INF; /*INF为一个大于所有权值的数*/ k=1;m=1; while (k\u003c=G-\u003en) /*求顶点集V-U与顶点集U之间的权值最小边*/ { if (closeedge[k].lowcost\u003cmincost \u0026\u0026 closeedge[k].lowcost!=0) { mincost= closeedge[k].lowcost; m=k; } k++; } printf(\"\\t\\t当前最小边的端点的值为：%c----%c\\n\",G-\u003evexs[m],closeedge[m].vex); closeedge[m].lowcost=0; vexnum--; for (j=1;j\u003c=G-\u003en;j++) /*修改其它顶点的边的权值和最小生成树顶点序号*/ if (G-\u003eedges[m][j]\u003ccloseedge[j].lowcost) { closeedge[j].ve","date":"2020-03-05","objectID":"/mgraph/:0:0","tags":["图","数据结构"],"title":"图","uri":"/mgraph/"},{"categories":["c语言","数据结构"],"content":"采用进位的方式达到两个200百位字符串数字相乘 做的没啥用,效率太低,傅里叶变换的那种暂时看不懂. #include\u003cstdio.h\u003e#define N 200 int main(){ char arr[N]; char ass[N]; int a[N]; int b[N]; int sum[2*N]; int mul[N][N]; int ii,j,k,ij,jj,ji; int mm,nn,tt,qqq,s,blog,gt; int ff; int flag=0; int x,y; scanf(\"%s\",arr); scanf(\"%s\",ass); qqq=0; s=0; for(j=0;j\u003cN;j++){ if(arr[j]==0){ break; } } for(k=0;k\u003cN;k++){ if(ass[k]==0){ break; } } for(ii=0;ii\u003cN;ii=ii+1){ if(arr[ii]\u003c=57\u0026\u0026arr[ii]\u003e=48){ x=arr[ii]; a[ii]=x-48; } } for(ij=0;ij\u003cN;ij=ij+1){ if(ass[ij]\u003c=57\u0026\u0026ass[ij]\u003e=48){ y=ass[ij]; b[ij]=y-48; } } for(jj=j-1;jj\u003e=0;jj--){ for(ji=k-1;ji\u003e=0;ji--){ mul[jj][ji]=a[jj]*b[ji]; } } for(tt=j+k-1;tt\u003e=0;tt--){ sum[tt]=0; } for(tt=j+k-1;tt\u003e=0;tt--){ for(mm=j-1;mm\u003e=0;mm--){ for(nn=k-1;nn\u003e=0;nn--){ blog=mm+nn; if(mul[mm][nn]\u003e=0){ if(blog==tt){ sum[tt]=sum[tt]+mul[mm][nn]; } if(sum[tt+1]\u003e9){ sum[tt]=sum[tt]+sum[tt+1]/10; sum[tt+1]=sum[tt+1]%10; } } } } } for(ff=0;ff\u003cj+k-1;ff++){ if(sum[ff]\u003e=0){ printf(\"%d\",sum[ff]); } } return 0; } ","date":"2020-03-05","objectID":"/largenumbermultiplication/:0:0","tags":["大数乘法(进位)","数据结构"],"title":"大数乘法","uri":"/largenumbermultiplication/"},{"categories":["c语言","数据结构"],"content":"采用进位的方式达到1100百位字符串数字相加 做的没啥用,效率太低,傅里叶变换的那种暂时看不懂. #include\u003cstdio.h\u003e#define N 1100 int max(int a,int b){ if(a\u003cb){ return b; } else{ return a; } } int min(int a,int b){ if(a\u003cb){ return a; } else{ return b; } } int main(){ char arr[N]; char ass[N]; int a[N]; int b[N]; int sum[N+1]; int s; int q; int x,y,d,f,o,j,k; int l,m,n; scanf(\"%d\",\u0026n) ; sum[0]=-199; for(int i=0 ; i\u003cn ; i++ ) { int g=0; scanf(\"%s\",\u0026arr); scanf(\"%s\",\u0026ass); for(d=0;d\u003cN;d++){ x=arr[d]; if(x==0){ break; } } for(f=0;f\u003cN;f++){ y=ass[f]; if(y==0){ break; } } for(o=0;o\u003cd;o++){ s=arr[o]; if(s\u003c=57\u0026\u0026s\u003e=48){ a[o]=arr[o]-48; } } for(j=0;j\u003cf;j++){ q=ass[j]; if(q\u003c=57\u0026\u0026q\u003e=48){ b[j]=ass[j]-48; } } x=max(d,f); y=min(d,f); for(k=x;k\u003e=0;k--){ if(k==0\u0026\u0026g==1){ sum[k]=1; } else{ if(k\u003ex-y){ if(d\u003cf){ sum[k]=a[y+k-1-x]+b[k-1]+g; } else{ sum[k]=a[k-1]+b[y+k-1-x]+g; } g=0; if(sum[k]\u003e=10){ g=1; sum[k]=sum[k]-10; } } else{ if(d\u003ef){ sum[k]=a[k-1]+g; g=0; } else{ sum[k]=b[k-1]+g; g=0; } } } } for(l=0;l\u003c=x;l++){ if(sum[0]==0){ sum[0]=-199;} if(sum[l]\u003c10\u0026\u0026sum[l]\u003e=0){ printf(\"%d\",sum[l]); } } printf(\"\\n\"); } return 0; } ","date":"2020-03-05","objectID":"/largenumberaddition/:0:0","tags":["大数加法(进位)","数据结构"],"title":"大数加法","uri":"/largenumberaddition/"},{"categories":["c语言","数据结构"],"content":" #include\u003cstdio.h\u003e#include\u003cmalloc.h\u003e#define MAX 100 typedef struct CTNode{ int child; struct CTNode *next; }CNode; typedef struct C{ char data; CNode *firstchild; }CTBox; typedef struct c{ CTBox nodes[MAX]; int n,r; }CTree; void Init(CTree *p){ char x; int i,j,m,h; CNode *s,*q; printf(\"\\n\\t\\t\\t请按下列规则输入，分字符和数字，字符决定该结点的值，数字决定这个结点是否为该结点位置的孩子\"); printf(\"\\n\\t\\t\\t数字为-1时跳到下一个结点,知道跳完所有结点才能结束\"); printf(\"\\n\\t\\t\\t请输入字符\"); scanf(\"%c\",\u0026x);getchar(); i=0; h=-1; p-\u003er=i; p-\u003en=i; while(j!=-1||p-\u003er!=i+1){ p-\u003enodes[i].data=x; if(h!=p-\u003er){ h=p-\u003er; p-\u003enodes[p-\u003er].firstchild=(CNode *)malloc(sizeof(CNode)); s=p-\u003enodes[p-\u003er].firstchild; } printf(\"\\n\\t\\t\\t请输入数字,决定是否成为%c的孩子\",p-\u003enodes[p-\u003er].data); scanf(\"%d\",\u0026j);getchar(); if(j!=-1){ q=(CNode *)malloc(sizeof(CNode)); s-\u003echild=i+1; s-\u003enext=q; q-\u003enext=NULL; s=q; p-\u003en++; printf(\"\\n\\t\\t\\t请输入该结点的值\"); scanf(\"%c\",\u0026x);getchar(); i++; } else{ s-\u003enext=NULL; p-\u003er++; } } } int flag=0; void xianxu(CTree *p,int root,int *tag){ if(p-\u003enodes[root].firstchild-\u003enext==NULL\u0026\u0026tag[root]==1){ return ; } else{ CNode *q; if(flag!=1){ printf(\"%c\\t\",p-\u003enodes[0].data); flag=1; } q=p-\u003enodes[root].firstchild; while(q-\u003enext!=NULL\u0026\u0026tag[root]!=1){ printf(\"%c\\t\",p-\u003enodes[q-\u003echild].data); xianxu(p,q-\u003echild,tag); tag[q-\u003echild]=1; q=q-\u003enext; } } } int count; int max(int a,int b){ if(a\u003eb) return a; else return b; } void deep(CTree *p,int root,int *tag,int i){ if(p-\u003enodes[root].firstchild-\u003enext==NULL\u0026\u0026tag[root]==1){ return ; } else{ CNode *q; q=p-\u003enodes[root].firstchild; while(q-\u003enext!=NULL\u0026\u0026tag[q-\u003echild]!=1){ if(tag[root]!=1){ i++; } deep(p,q-\u003echild,tag,i); count=max(count,i); tag[q-\u003echild]=1; q=q-\u003enext; i=1; } } } void main(){ CTree p; int visited[MAX]={0}; int i,j; i=0; count=0; Init(\u0026p); // printf(\"\\n\"); xianxu(\u0026p,i,visited); // for(j=0;j\u003cMAX;j++) // visited[j]=0; // printf(\"\\n\"); // i=0; // j=1; // deep(\u0026p,i,visited,j); // printf(\"%d\",count); } ","date":"2020-03-05","objectID":"/childlinkedlist/:0:0","tags":["孩子链表","数据结构"],"title":"孩子链表","uri":"/childlinkedlist/"},{"categories":["c语言","数据结构"],"content":" #include\u003cstdio.h\u003e#define N 1100 int max(int a,int b){ if(a\u003cb){ return b; } else{ return a; } } int min(int a,int b){ if(a\u003cb){ return a; } else{ return b; } } int main(){ char arr[N]; char ass[N]; int a[N]; int b[N]; int sum[N+1]; int s; int q; int x,y,d,f,o,j,k; int l,m,n; scanf(\"%d\",\u0026n) ; sum[0]=-199; for(int i=0 ; i\u003cn ; i++ ) { int g=0; scanf(\"%s\",\u0026arr); scanf(\"%s\",\u0026ass); for(d=0;d\u003cN;d++){ x=arr[d]; if(x==0){ break; } } for(f=0;f\u003cN;f++){ y=ass[f]; if(y==0){ break; } } for(o=0;o\u003cd;o++){ s=arr[o]; if(s\u003c=57\u0026\u0026s\u003e=48){ a[o]=arr[o]-48; } } for(j=0;j\u003cf;j++){ q=ass[j]; if(q\u003c=57\u0026\u0026q\u003e=48){ b[j]=ass[j]-48; } } x=max(d,f); y=min(d,f); for(k=x;k\u003e=0;k--){ if(k==0\u0026\u0026g==1){ sum[k]=1; } else{ if(k\u003ex-y){ if(d\u003cf){ sum[k]=a[y+k-1-x]+b[k-1]+g; } else{ sum[k]=a[k-1]+b[y+k-1-x]+g; } g=0; if(sum[k]\u003e=10){ g=1; sum[k]=sum[k]-10; } } else{ if(d\u003ef){ sum[k]=a[k-1]+g; g=0; } else{ sum[k]=b[k-1]+g; g=0; } } } } for(l=0;l\u003c=x;l++){ if(sum[0]==0){ sum[0]=-199;} if(sum[l]\u003c10\u0026\u0026sum[l]\u003e=0){ printf(\"%d\",sum[l]); } } printf(\"\\n\"); } return 0; } ","date":"2020-03-05","objectID":"/queue/:0:0","tags":["小排序","数据结构"],"title":"小排序","uri":"/queue/"},{"categories":["c语言","数据结构"],"content":"各种排序!这些内容还没有复刻,是邱桃荣老师做的.方便以后学习 #include \u003cstdio.h\u003e#include \u003cconio.h\u003e#include \u003cstring.h\u003e#include \u003cmalloc.h\u003e#define Keytype int /*关键字类型定义*/#define MAX_LIST_LEN 100 /*定义线性表的最大长度*/typedef struct { /*定义元素类型 */ Keytype key; /*关键字定义*/ } ElemType; typedef struct { /*查找表顺序存储结构定义*/ ElemType elem[MAX_LIST_LEN+1]; /*elem[0]元素当作工作单元*/ int length; /* 查找表长度*/ }Seq_Table; Seq_Table seqtbl; typedef struct NODE{ /*查找表链式存储结构定义*/ ElemType elem; /*其中ElemType 定义同顺序存储结构*/ struct NODE *next; }LINK_NODE; #define ENDVALUE -1 typedef struct BINNODE{ /*二叉排序树定义*/ Keytype key; /*关键字值*/ struct BINNODE *lchild ,*rchild; /*左右指针*/ } BSTNode, *BSTree; /*显示主界面*/ void PrintMenu() { printf(\"\\n\\n\\n\\n\\n\"); printf(\"\\t\\t\\t-- 各 类 查 找 综 合 演 示 -- \\n\"); printf(\"\\n\\t\\t\\t************************************\"); printf(\"\\n\\t\\t\\t* 1-------静 态 查 找 *\"); printf(\"\\n\\t\\t\\t* 2-------动 态 查 找 *\"); printf(\"\\n\\t\\t\\t* 0-------退 出 *\"); printf(\"\\n\\t\\t\\t************************************\\n\"); printf(\"\\t\\t\\t请选择功能号(0--2)：\"); } /* 查找表初始化*/ void ElemInit() { int i=1; ElemType elem; printf(\"\\n请注意! 假定系统查找表的最大长度为 %d\" ,MAX_LIST_LEN); printf(\"\\n请输入若干( \u003c%d )查找表初始元素的关键字值(整数),以%d结束.\\n\",MAX_LIST_LEN,ENDVALUE); seqtbl.length=0; /*初始化查找表长度*/ while (1) { scanf(\"%d\",\u0026elem.key); if (elem.key==ENDVALUE) break; else seqtbl.elem[i++].key=elem.key; /*从第1号单元开始存放数据*/ seqtbl.length++; } } /* 输出查找表的所有元素*/ void output(Seq_Table seqtbl1) { int k; printf (\"\\n\\t查找表的地址单元: \"); for(k=1;k\u003c=seqtbl1.length ;k++) printf(\"%4d\",k); printf (\"\\n\\t元素关键字序列为: \"); for(k=1;k\u003c=seqtbl1.length ;k++) printf(\"%4d\",seqtbl1.elem[k]); } /*数据输入界面*/ int input() { int x; while(1) { printf(\"\\n请输入你要查找元素的关键字值(整型):\"); scanf(\"%d\",\u0026x); getchar(); if (!((x\u003e=-32768) \u0026\u0026 (x\u003c=32767))) printf(\"\\n关键字输入无效,请重新输入!\"); else break; } return x; } /*显示静态查找主界面*/ void PrintStaticMenu() { printf(\"\\n\\n\\n\\n\\n\"); printf(\"\\t\\t\\t-- 静 态 查 找 综 合 演 示 -- \\n\"); printf(\"\\n\\t\\t\\t*****************************************\"); printf(\"\\n\\t\\t\\t* 1------- 查找表初始化 *\"); printf(\"\\n\\t\\t\\t* 2------- 顺 序 查 找 *\"); printf(\"\\n\\t\\t\\t* 3------- 顺 序 查 找(设监视哨) *\"); printf(\"\\n\\t\\t\\t* 4------- 折 半 查 找 *\"); printf(\"\\n\\t\\t\\t* 0------- 返 回主界 面 *\"); printf(\"\\n\\t\\t\\t*****************************************\\n\"); printf(\"\\t\\t\\t请选择功能号(0--4)：\"); } /*顺序查找 未设置监视哨情形*/ int SeqSearch(Seq_Table Seq_Tbl, Keytype Sea_Key) /*Seq_Tbl为查找表，Sea_Key 为待查找的关键字.*/ { int pos, len; pos=1; len=Seq_Tbl.length; /*当没有到达查找表尾且没有找到时循环;*/ while (pos\u003c=len \u0026\u0026 Seq_Tbl.elem[pos].key!=Sea_Key) pos++; if (pos\u003elen ) /*循环结束是因为没有找到此元素*/ return 0; else /*找到此元素 */ return pos; } /*顺序查找 设置监视哨情形*/ int SeqSearchSetMonitor(Seq_Table Seq_Tbl, Keytype Sea_Key) { int i; Seq_Tbl.elem[0].key=Sea_Key; for(i=MAX_LIST_LEN;i!=0\u0026\u0026Seq_Tbl.elem[0].key==-1;i--){ if(Seq_Tbl.elem[0].key==Sea_Key){ break; } } return i; } /*冒泡排序*/ void BubbleSort( Seq_Table *Seq_Tbl ) { int i,j; ElemType temp; for ( i=1 ; i\u003c=Seq_Tbl-\u003elength-1 ; i++ ) /* 外循环，i 表示趟数，总共需要len-1趟*/ { for ( j=1 ; j\u003c=Seq_Tbl-\u003elength-i ;j++ ) /*内循环，每趟排序中所需比较的次数*/ if ( Seq_Tbl-\u003eelem[j].key\u003eSeq_Tbl-\u003eelem[j+1].key) /*前面元素大于后面元素，则交换*/ { temp=Seq_Tbl-\u003eelem[j] ; Seq_Tbl-\u003eelem[j]=Seq_Tbl-\u003eelem[j+1]; Seq_Tbl-\u003eelem[j+1]=temp;} } } /*折半查找*/ int BinarySearch(Seq_Table Seq_Tbl , Keytype Sea_Key) /*Seq_Tbl 为查找表，Sea_Key 为待查找的关键字*/ { int mid, low, high; low=1; high=Seq_Tbl.length; while (low\u003c=high) { mid=(low+high)/2; if (Seq_Tbl.elem[mid].key\u003cSea_Key) /*若存在，则必在右半区*/ low=mid+1; else if (Seq_Tbl.elem[mid].key\u003eSea_Key) /*若存在，则必在左半区*/ high=mid-1; else /*等于待查找的关键字，查找结束*/ break; } if (low\u003ehigh) /*没有找到*/ return 0; else return mid; } /*静态查找主程序*/ void StaticSearch( ) { char static_func_choice; PrintStaticMenu(); getchar(); /*读主界面的回车符*/ static_func_choice=getchar(); while (static_func_choice!='0') { switch (static_func_choice) { case '1': ElemInit(); break; case '2': /*顺序查找*/ { int retval,seakey; seakey=input(); retval=SeqSearch(seqtbl, seakey); output(seqtbl); printf(\"\\n\\t你要查找的关键字为: %d\",seakey); if (retval\u003e0) printf(\"\\n\\t查找成功,关键字为 %d 的元素位于第 %d 个位置!\",seakey,retval); else printf(\"\\n\\t对不起,关键字为 %d 的元素不存在.\",seakey); break; } case '3' : /","date":"2020-03-05","objectID":"/sort/:0:0","tags":["排序","数据结构"],"title":"排序","uri":"/sort/"},{"categories":["c语言","数据结构"],"content":"各种查找!这些内容还没有复刻,是邱桃荣老师做的.方便以后学习 #include \u003cstdio.h\u003e#include \u003cconio.h\u003e#include \u003cstring.h\u003e#include \u003cmalloc.h\u003e#define Keytype int /*关键字类型定义*/#define MAX_LIST_LEN 100 /*定义线性表的最大长度*/typedef struct { /*定义元素类型 */ Keytype key; /*关键字定义*/ } ElemType; typedef struct { /*查找表顺序存储结构定义*/ ElemType elem[MAX_LIST_LEN+1]; /*elem[0]元素当作工作单元*/ int length; /* 查找表长度*/ }Seq_Table; Seq_Table seqtbl; typedef struct NODE{ /*查找表链式存储结构定义*/ ElemType elem; /*其中ElemType 定义同顺序存储结构*/ struct NODE *next; }LINK_NODE; #define ENDVALUE -1 typedef struct BINNODE{ /*二叉排序树定义*/ Keytype key; /*关键字值*/ struct BINNODE *lchild ,*rchild; /*左右指针*/ } BSTNode, *BSTree; /*显示主界面*/ void PrintMenu() { printf(\"\\n\\n\\n\\n\\n\"); printf(\"\\t\\t\\t-- 各 类 查 找 综 合 演 示 -- \\n\"); printf(\"\\n\\t\\t\\t************************************\"); printf(\"\\n\\t\\t\\t* 1-------静 态 查 找 *\"); printf(\"\\n\\t\\t\\t* 2-------动 态 查 找 *\"); printf(\"\\n\\t\\t\\t* 0-------退 出 *\"); printf(\"\\n\\t\\t\\t************************************\\n\"); printf(\"\\t\\t\\t请选择功能号(0--2)：\"); } /* 查找表初始化*/ void ElemInit() { int i=1; ElemType elem; printf(\"\\n请注意! 假定系统查找表的最大长度为 %d\" ,MAX_LIST_LEN); printf(\"\\n请输入若干( \u003c%d )查找表初始元素的关键字值(整数),以%d结束.\\n\",MAX_LIST_LEN,ENDVALUE); seqtbl.length=0; /*初始化查找表长度*/ while (1) { scanf(\"%d\",\u0026elem.key); if (elem.key==ENDVALUE) break; else seqtbl.elem[i++].key=elem.key; /*从第1号单元开始存放数据*/ seqtbl.length++; } } /* 输出查找表的所有元素*/ void output(Seq_Table seqtbl1) { int k; printf (\"\\n\\t查找表的地址单元: \"); for(k=1;k\u003c=seqtbl1.length ;k++) printf(\"%4d\",k); printf (\"\\n\\t元素关键字序列为: \"); for(k=1;k\u003c=seqtbl1.length ;k++) printf(\"%4d\",seqtbl1.elem[k]); } /*数据输入界面*/ int input() { int x; while(1) { printf(\"\\n请输入你要查找元素的关键字值(整型):\"); scanf(\"%d\",\u0026x); getchar(); if (!((x\u003e=-32768) \u0026\u0026 (x\u003c=32767))) printf(\"\\n关键字输入无效,请重新输入!\"); else break; } return x; } /*显示静态查找主界面*/ void PrintStaticMenu() { printf(\"\\n\\n\\n\\n\\n\"); printf(\"\\t\\t\\t-- 静 态 查 找 综 合 演 示 -- \\n\"); printf(\"\\n\\t\\t\\t*****************************************\"); printf(\"\\n\\t\\t\\t* 1------- 查找表初始化 *\"); printf(\"\\n\\t\\t\\t* 2------- 顺 序 查 找 *\"); printf(\"\\n\\t\\t\\t* 3------- 顺 序 查 找(设监视哨) *\"); printf(\"\\n\\t\\t\\t* 4------- 折 半 查 找 *\"); printf(\"\\n\\t\\t\\t* 0------- 返 回主界 面 *\"); printf(\"\\n\\t\\t\\t*****************************************\\n\"); printf(\"\\t\\t\\t请选择功能号(0--4)：\"); } /*顺序查找 未设置监视哨情形*/ int SeqSearch(Seq_Table Seq_Tbl, Keytype Sea_Key) /*Seq_Tbl为查找表，Sea_Key 为待查找的关键字.*/ { int pos, len; pos=1; len=Seq_Tbl.length; /*当没有到达查找表尾且没有找到时循环;*/ while (pos\u003c=len \u0026\u0026 Seq_Tbl.elem[pos].key!=Sea_Key) pos++; if (pos\u003elen ) /*循环结束是因为没有找到此元素*/ return 0; else /*找到此元素 */ return pos; } /*顺序查找 设置监视哨情形*/ int SeqSearchSetMonitor(Seq_Table Seq_Tbl, Keytype Sea_Key) { int i; Seq_Tbl.elem[0].key=Sea_Key; for(i=MAX_LIST_LEN;i!=0\u0026\u0026Seq_Tbl.elem[0].key==-1;i--){ if(Seq_Tbl.elem[0].key==Sea_Key){ break; } } return i; } /*冒泡排序*/ void BubbleSort( Seq_Table *Seq_Tbl ) { int i,j; ElemType temp; for ( i=1 ; i\u003c=Seq_Tbl-\u003elength-1 ; i++ ) /* 外循环，i 表示趟数，总共需要len-1趟*/ { for ( j=1 ; j\u003c=Seq_Tbl-\u003elength-i ;j++ ) /*内循环，每趟排序中所需比较的次数*/ if ( Seq_Tbl-\u003eelem[j].key\u003eSeq_Tbl-\u003eelem[j+1].key) /*前面元素大于后面元素，则交换*/ { temp=Seq_Tbl-\u003eelem[j] ; Seq_Tbl-\u003eelem[j]=Seq_Tbl-\u003eelem[j+1]; Seq_Tbl-\u003eelem[j+1]=temp;} } } /*折半查找*/ int BinarySearch(Seq_Table Seq_Tbl , Keytype Sea_Key) /*Seq_Tbl 为查找表，Sea_Key 为待查找的关键字*/ { int mid, low, high; low=1; high=Seq_Tbl.length; while (low\u003c=high) { mid=(low+high)/2; if (Seq_Tbl.elem[mid].key\u003cSea_Key) /*若存在，则必在右半区*/ low=mid+1; else if (Seq_Tbl.elem[mid].key\u003eSea_Key) /*若存在，则必在左半区*/ high=mid-1; else /*等于待查找的关键字，查找结束*/ break; } if (low\u003ehigh) /*没有找到*/ return 0; else return mid; } /*静态查找主程序*/ void StaticSearch( ) { char static_func_choice; PrintStaticMenu(); getchar(); /*读主界面的回车符*/ static_func_choice=getchar(); while (static_func_choice!='0') { switch (static_func_choice) { case '1': ElemInit(); break; case '2': /*顺序查找*/ { int retval,seakey; seakey=input(); retval=SeqSearch(seqtbl, seakey); output(seqtbl); printf(\"\\n\\t你要查找的关键字为: %d\",seakey); if (retval\u003e0) printf(\"\\n\\t查找成功,关键字为 %d 的元素位于第 %d 个位置!\",seakey,retval); else printf(\"\\n\\t对不起,关键字为 %d 的元素不存在.\",seakey); break; } case '3' : /","date":"2020-03-05","objectID":"/search/:0:0","tags":["查找","数据结构"],"title":"查找","uri":"/search/"},{"categories":["c语言","数据结构"],"content":"树和森林,两者之间的转换就是第一棵树的新子树是第二棵树,递归一下就行. #include\u003cstdio.h\u003e#include\u003cmalloc.h\u003e#include\u003cstring.h\u003e#define MAX 10 #define M 100 typedef struct HTNode{ char data[MAX]; int i; struct HTNode *Lchild,*Rchild; }Huffman; typedef struct ListNode{ int data; struct ListNode *next; }LN; LN *head; void INit(){ LN *q,*p; int x; head=(LN *)malloc(sizeof(LN)); p=head; head-\u003enext=NULL; scanf(\"%d\",\u0026x);getchar(); while(x!=0){ q=(LN *)malloc(sizeof(LN)); q-\u003enext=NULL; q-\u003edata=x; p-\u003enext=q; p=q; scanf(\"%d\",\u0026x);getchar(); } } void Insert(int x){ LN *q,*s; q=head; while(q-\u003enext!=NULL){ q=q-\u003enext; } s=(LN *)malloc(sizeof(LN)); q-\u003enext=s; s-\u003edata=x; s-\u003enext=NULL; } void Delete(LN *p,int i){ LN *q,*s; q=s=head; if(s-\u003enext==NULL) return ; while(s-\u003edata!=i\u0026\u0026s!=NULL){ q=s; s=s-\u003enext; } if(s!=NULL) q-\u003enext=s-\u003enext; } int min(LN *p){ LN *q,*s; int i; q=head; i=q-\u003enext-\u003edata; while(q-\u003enext!=NULL){ q=q-\u003enext; if(q-\u003edata\u003c=i){ i=q-\u003edata; printf(\"{%d}\",i); } } return i; } Huffman *InitHuffman( ){ Huffman *L,*R,*p,*s,*f,*t,*z[M]; LN *q; int l,r,i,j,flag,k; flag=-1; i=k=0; j=0; INit( ); q=head; l=min(head); z[i]=(Huffman *)malloc(sizeof(Huffman)); s=(Huffman *)malloc(sizeof(Huffman)); z[i]-\u003eLchild=z[i]-\u003eRchild=s-\u003eLchild=s-\u003eRchild=NULL; z[i]-\u003ei=0; s-\u003ei=l; Delete(head,l); r=min(head); Delete(head,r); while(1){ for(j=0;j\u003c=i;j++){ if(z[j]-\u003ei==l||z[j]-\u003ei==r){ flag=1; printf(\"flag==1\"); break; } } for(k=0;k\u003c=i;k++){ if(k==j) continue; if(z[k]-\u003ei==l||z[k]-\u003ei==r){ flag=2; printf(\"flag==2\"); break; } } if(flag==2){ f=(Huffman *)malloc(sizeof(Huffman)); f-\u003eLchild=NULL; f-\u003eRchild=NULL; f-\u003eLchild=z[k]; f-\u003eRchild=z[j]; f-\u003ei=f-\u003eLchild-\u003ei+f-\u003eRchild-\u003ei; t=z[k]=f; flag=0; } else{ if(flag==1){ f=(Huffman *)malloc(sizeof(Huffman)); f-\u003eLchild=NULL; f-\u003eRchild=NULL; f-\u003eLchild=p; f-\u003eRchild=z[j]; f-\u003ei=f-\u003eLchild-\u003ei+f-\u003eRchild-\u003ei; t=p=f; flag=0; } else{ if(s-\u003ei==l||s-\u003ei==r){ p=(Huffman *)malloc(sizeof(Huffman)); p-\u003eRchild=NULL; printf(\"%d\",s-\u003ei); p-\u003eLchild=s; p-\u003eRchild=(Huffman *)malloc(sizeof(Huffman)); p-\u003eRchild-\u003eLchild=p-\u003eRchild-\u003eRchild=NULL; if(s-\u003ei==l) p-\u003eRchild-\u003ei=r; else p-\u003eRchild-\u003ei=l; p-\u003ei=p-\u003eLchild-\u003ei+p-\u003eRchild-\u003ei; t=s=p; } else{ i++; R=(Huffman *)malloc(sizeof(Huffman)); L=(Huffman *)malloc(sizeof(Huffman)); z[i]=(Huffman *)malloc(sizeof(Huffman)); R-\u003eLchild=R-\u003eRchild=L-\u003eLchild=L-\u003eRchild=z[i]-\u003eLchild=z[i]-\u003eRchild=NULL; L-\u003ei=l; R-\u003ei=r; z[i]-\u003eLchild=L; z[i]-\u003eRchild=R; z[i]-\u003ei=z[i]-\u003eLchild-\u003ei+z[i]-\u003eRchild-\u003ei; t=z[i]; } } } Insert(t-\u003ei); if(head-\u003enext-\u003enext!=NULL){ l=min(head); Delete(head,l); r=min(head); Delete(head,r); } else{ break; } } return p; } void xianxu(Huffman *p){ if(p==NULL) return ; else{ printf(\"%d\\t\",p-\u003ei); xianxu(p-\u003eLchild); xianxu(p-\u003eRchild); } } void main(){ Huffman *p; p=InitHuffman(); xianxu(p); } ","date":"2020-03-05","objectID":"/treeandforest/:0:0","tags":["树和森林","数据结构"],"title":"树和森林","uri":"/treeandforest/"},{"categories":["c语言","数据结构"],"content":" #include\u003cstdio.h\u003e#include\u003cmalloc.h\u003etypedef struct CSNode{ char data; struct CSNode *firstchild,*nextsibling; }CSN; CSN *Init(){ CSN *p; char x; scanf(\"%c\",\u0026x);getchar(); if(x!=' '){ p=(CSN *)malloc(sizeof(CSN)); p-\u003edata=x; printf(\"要不要给%c结点创造子节点\",p-\u003edata); p-\u003efirstchild=Init(); printf(\"要不要给%c结点创造兄弟\",p-\u003edata); p-\u003enextsibling=Init(); } else{ p=NULL; } return p; } void xianxu(CSNode *p){ if(p==NULL) return ; else{ printf(\"%c\\t\",p-\u003edata); if(p-\u003efirstchild!=NULL) xianxu(p-\u003efirstchild); if(p-\u003enextsibling!=NULL) xianxu(p-\u003enextsibling); } } void zhongxu(CSNode *p){ if(p==NULL) return ; else{ if(p-\u003efirstchild!=NULL) zhongxu(p-\u003efirstchild); printf(\"%c\\t\",p-\u003edata); if(p-\u003enextsibling!=NULL) zhongxu(p-\u003enextsibling); } } void main(){ CSN *p; p=Init(); xianxu(p); printf(\"\\n\"); zhongxu(p); } ","date":"2020-03-05","objectID":"/forestturnsintobinarytree/:0:0","tags":["森林转成二叉树","数据结构"],"title":"森林转成二叉树","uri":"/forestturnsintobinarytree/"},{"categories":["c语言","数据结构"],"content":"通过链表实现栈结构 #include\u003cstdio.h\u003e#include\u003cmalloc.h\u003etypedef int SElemType; typedef struct SqStack{ SElemType *base; SElemType *top; int stacksize; }SStack; void InitStack(SStack *p){ p-\u003ebase=p-\u003etop=(SStack *)malloc(sizeof(SStack)); if(p-\u003ebase==NULL){ return; } else{ p-\u003ebase=NULL; p-\u003estacksize=0; } } void DestoryStack(SStack *p){ free(p-\u003ebase); free(p-\u003etop); } void CLearStack(SStack *p){ while(p-\u003etop!=p-\u003ebase){ p-\u003etop=p-\u003etop-1; p-\u003estacksize=p-\u003estacksize-1; } } int StackEmpty(SStack *p){ if(p-\u003ebase==p-\u003etop){ return 1; } else{ return 0; } } int StackLength(SStack *p){ int i; SElemType *q; q=p-\u003etop; i=0; while(q==p-\u003ebase){ q=q-1; i++; } return i; } int Get(SStack *p){ int i; if(p-\u003etop==p-\u003ebase) return 0; else{ i=*p-\u003etop; return i; } } void Push(SStack *p){ if(p-\u003etop-p-\u003ebase\u003e=p-\u003estacksize){ p-\u003ebase=(int *)realloc(p-\u003ebase,(p-\u003estacksize+10)*sizeof(int)); if } } ","date":"2020-03-05","objectID":"/linearstack/:0:0","tags":["线性栈","数据结构"],"title":"线性栈","uri":"/linearstack/"},{"categories":["学习记录","书面知识"],"content":"计算机组成原理 2020/10/12 冯•诺依曼计算及特点 计算机由武大部分组成. 指令和数据以同等地位存于存储器,可按地址寻访 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心 现代计算机结构以存储器为核心. 存储单元:每个存储单元存放一串二进制代码. 存储字:存储单元中二进制代码的组合. 存储字长:存储单元中二进制代码的位数. 存储元:即存储二进制的电子元件,每个存储元可存1bit. 运算器 运算器:用于实现算术运算,逻辑运算. ACC(Accumulation):累加器,用于存放操作数,或运算结果. MQ(Multiple-Quotient Register):乘商寄存器,在乘、除运算时,用于存放操作数或运算结果. x:通用的操作数寄存器,用于存放操作数 ALU(Arithmetic and Logic Unit):算数逻辑单元,通过内部复杂的电路实现算数运算,逻辑运算. 减法操作过程: 乘法操作过程: 除法操作过程: 控制器 CU(Control Unit):控制单元,分析指令,给出控制信号. IR(Instruction Register):指令寄存器,存放当前执行的指令 PC(Program Counter):程序计数器.存放下一条指令地址,有自动加1功能. 取数指令过程 片内总线:芯片内部的总线 系统总线:计算机各部门之间的信息传输线 $$ \\begin{cases} 数据总线 \\qquad 双向.与机器字长,存储字长有关\\\\ 地址总线 \\qquad 单向,与存储地址,I/O地址有关 \\\\ 控制总线 \\qquad 有出有入 \\\\ \\end{cases} $$ 总线的性能指标: 总线宽度: 数据线的根数. 标准传输率: 每秒传输的最大字节数(MBps). 时钟同步/异步: 同步、不同步 总线复用: 地址线与数据线复用 信号线数: 地址线,数据线和控制线的总和. 总线控制方式: 突发,自动,仲裁,逻辑,计数. 其他指标: 负载能力. 总线传输周期 $$ \\begin{cases} 申请分配阶段 \\qquad 主模块申请,总线仲裁决定 \\\\ 寻址阶段 \\qquad\\qquad 主模块向从模块给出地址和命令 \\\\ 传数阶段 \\qquad\\qquad 主模块和从模块交换数据 \\\\结束阶段 \\qquad\\qquad 主模块撤消有关信息 \\\\ \\end{cases} $$ 总线通信的四种方式 $$ \\begin{cases} 同步通信 \\qquad 由同意时标控制数据传送\\\\ 异步通信 \\qquad 采用应答方式,没有公共时间标准 \\\\ 半同步通信 \\qquad 同步,异步结合. \\\\ 分离式通信 \\qquad 充分挖掘系统总线每个瞬间的潜力 \\\\ \\end{cases} $$ $$ CPU主频(时钟频率) = \\frac{1}{CPU时钟周期} \\\\ CPI(Clock cycle Per Instruction) = 执行一条指令所需要的时钟周期数 \\\\ IPS(Instructions Per Second)每秒执行多少条指令\\qquad\\qquad\\qquad \\\\ IPS = \\frac{主频}{平均CPI} FLops(Floating Point Operations Per second)每秒执行多少浮点运算.\\\\ $$ 数据通路带宽:数据总线一次所能并行传送信息的位数. 吞吐量:指系统在单位时间内处理请求的数量. 响应时间:指从用户向计算机发送一个请求,到系统对该请求的响应所需的等待时间. 负数补码的算术移位： 右移：高位补1，低位舍弃 左移：低位补0，高位舍弃 正负数移码的填补代码 码制 添补代码 正数 原码、反码、补码 0 负数 原码 0 反码 1 补码 左移添0 右移添1 正数+正数,如果得到负数,那么就发生了上溢.负数+负数,若果是正数,那么就发生了下溢. 原码乘法为:(逻辑右移) 当前位=1,则ACC加上被乘数. 当前位为0,则ACC加上0. 补码乘法运算:(算术右移:符号位不动,数值位右移,正数右移补0,负数右移补1) 辅助位-MQ中最低位=1时,(ACC)+[x]补. 辅助位-MQ中最低位=0时,(ACC)+0. 辅助位-MQ中最低位=-1时,(ACC)+[-x]补. 原码除法运算:(逻辑左移) 恢复余数法: 计算机先上1,如果余数是负数,则把上的1改为0,如果余数是正的则不改动. 加减交替法: 计算机先减一次 补,如果余数是正的,则上1,如果是负的则上0. 补码除法:加减交替法 余数和除数同号,商1,余数左移一位减去除数. 余数和除数异号,商0,余数左移一位加上除数.重复n次. 浮点数尾数的规格化. 规定尾数的最高数值位必须是一个有效值. 左规:当浮点数运算的结果为非规格化时要进行规格化处理,将尾数算数左移一位,阶码减1. 右规:当浮点数运算的结果尾数出现溢出(双符号位为01或10)时,将尾数算数右移一位.阶码加1. 浮点数的划分 类型 数符 阶码 尾数数值 总位数 偏置值 十六进制 十进制 短浮点数 1 8 23 32 7FH 127 浮点数 1 11 52 64 3FFH 1023 临时浮点数 1 15 64 80 3FFFH 16383 阶码真值=移码-偏移量. 当阶码E全为0,尾数不全为0时,表示非规格小数$\\pm$(0.M)$\\times2^{-126}$ 当阶码E全为0,尾数M全为0.表示真值$\\pm$0. 当阶码E全为1,尾数M全为0时,表示无穷大$\\pm\\infty$. 当阶码E全为1,尾数M全为0时,表示非数值\"NaN\"(Not ａ Number). ","date":"2020-03-05","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:0:0","tags":["计算机组成原理"],"title":"计算机组成原理","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["c语言","数据结构"],"content":"这是一个课后习题,题目说的是,要做到银行排队的模拟,要求模拟得能按照每个队伍的最短时间,进行排队. 瞎写的,那时候写的很稚嫩….. #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cmalloc.h\u003etypedef int AdjType; typedef struct QNode{ AdjType i; AdjType date; struct QNode *next; }Q; typedef struct Sqlist{ Q *front; Q *rear; }S; void Init(S* p){ p-\u003erear=p-\u003efront=(Q *)malloc(sizeof( Q )); p-\u003erear-\u003enext=NULL; printf(\"\\n\\t\\t\\t银行计划初始化成功!\"); } void insert(S *p,int i,int j){ Q *q; printf(\"\\n\\t\\t\\t第%d位客户进入了银行他要用的时间是%d\\t\",i,j); q=(Q *)malloc(sizeof(Q)); q-\u003edate=j; p-\u003erear-\u003enext=q; p-\u003erear=q; q-\u003ei=i; p-\u003erear-\u003enext=NULL; } void Delete(S *p,int i){ Q *q; if(p-\u003efront==p-\u003erear) return; q=p-\u003efront-\u003enext; if(q-\u003edate==0\u0026\u0026i==1){ p-\u003efront=p-\u003efront-\u003enext; printf(\"\\n\\t\\t\\t第%d客户已经离开了银行\\n\",q-\u003ei); } } int fanhui(S *p){ int i; Q *q; q=p-\u003efront; i=0; if(q==p-\u003erear){ return 0; } while(q!=p-\u003erear){ i++; return i; } } void jianyi(S *p){ Q *q; if(p-\u003efront==p-\u003erear) return ; q=p-\u003efront-\u003enext; if(q-\u003edate\u003e0) q-\u003edate=q-\u003edate-1; } int shijianhe(S *p){ int j; Q *q; j=0; q=p-\u003efront; do{ q=q-\u003enext; j=q-\u003edate+j; }while(q!=p-\u003erear); return j; } int min(int a,int b){ if(a\u003eb) return b; else return a; } void xianshi(S *p,int i){ Q *q; if(p-\u003efront==p-\u003erear) return ; q=p-\u003efront-\u003enext; printf(\"\\t第%d位客户在%d窗口,数值是%d\",q-\u003ei,i+1,q-\u003edate); } void main(){ S a[4]; int visited[4]={0}; int b[4]; int i,k,l,s; int flag; int j; int x; x=1; for(k=0;k\u003c=3;k++){ Init(\u0026a[k]); } for(i=1;x!=0;i++){ if(x==1){ s=31; for(k=0;k\u003c4;k++){ b[k]=0; } j=rand()%30+1; flag=0; for(k=0;k\u003c4;k++){ b[k]=fanhui(\u0026a[k]); if(fanhui(\u0026a[k])==0){ insert(\u0026a[k],i,j); visited[k]=1; break; } b[k]=fanhui(\u0026a[k]); } if(b[1]\u0026\u0026b[2]\u0026\u0026b[0]\u0026\u0026b[3]){ for(k=0;k\u003c4;k++){ s=min(shijianhe(\u0026a[k]),s); } for(k=0;k\u003c4;k++){ if(s==shijianhe(\u0026a[k])){ insert(\u0026a[k],i,j); visited[k]=1; break; } } } } for(k=0;k\u003c4;k++){ printf(\"\\n\\t\\t\"); xianshi(\u0026a[k],k); } for(k=0;k\u003c4;k++){ jianyi(\u0026a[k]); } for(k=0;k\u003c4;k++){ Delete(\u0026a[k],visited[k]); } printf(\"\\n\\t\\t\\t请输入控制字0结束，1继续产生随机数，2不产生随机数\"); scanf(\"%d\",\u0026x); } printf(\"\\n\\t\\t\\t银行下班了\"); } ","date":"2020-03-05","objectID":"/bank/:0:0","tags":["数据结构","课后习题"],"title":"银行排队实现","uri":"/bank/"},{"categories":["c语言","数据结构"],"content":"简单链表,增删改查 #include\u003cstdio.h\u003e#include\u003cmalloc.h\u003e#include\u003cstring.h\u003e#define MAX 10 #define M 100 typedef struct HTNode{ char data[MAX]; int i; struct HTNode *Lchild,*Rchild; }Huffman; typedef struct ListNode{ int data; struct ListNode *next; }LN; LN *head; void INit(){ LN *q,*p; int x; head=(LN *)malloc(sizeof(LN)); p=head; head-\u003enext=NULL; scanf(\"%d\",\u0026x);getchar(); while(x!=0){ q=(LN *)malloc(sizeof(LN)); q-\u003enext=NULL; q-\u003edata=x; p-\u003enext=q; p=q; scanf(\"%d\",\u0026x);getchar(); } } void Insert(int x){ LN *q,*s; q=head; while(q-\u003enext!=NULL){ q=q-\u003enext; } s=(LN *)malloc(sizeof(LN)); q-\u003enext=s; s-\u003edata=x; s-\u003enext=NULL; } void Delete(LN *p,int i){ LN *q,*s; q=s=head; if(s-\u003enext==NULL) return ; while(s-\u003edata!=i\u0026\u0026s!=NULL){ q=s; s=s-\u003enext; } if(s!=NULL) q-\u003enext=s-\u003enext; } int min(LN *p){ LN *q,*s; int i; q=head; i=q-\u003enext-\u003edata; while(q-\u003enext!=NULL){ q=q-\u003enext; if(q-\u003edata\u003c=i){ i=q-\u003edata; printf(\"{%d}\",i); } } return i; } Huffman *InitHuffman( ){ Huffman *L,*R,*p,*s,*f,*t,*z[M]; LN *q; int l,r,i,j,flag,k; flag=-1; i=k=0; j=0; INit( ); q=head; l=min(head); z[i]=(Huffman *)malloc(sizeof(Huffman)); s=(Huffman *)malloc(sizeof(Huffman)); z[i]-\u003eLchild=z[i]-\u003eRchild=s-\u003eLchild=s-\u003eRchild=NULL; z[i]-\u003ei=0; s-\u003ei=l; Delete(head,l); r=min(head); Delete(head,r); while(1){ for(j=0;j\u003c=i;j++){ if(z[j]-\u003ei==l||z[j]-\u003ei==r){ flag=1; printf(\"flag==1\"); break; } } for(k=0;k\u003c=i;k++){ if(k==j) continue; if(z[k]-\u003ei==l||z[k]-\u003ei==r){ flag=2; printf(\"flag==2\"); break; } } if(flag==2){ f=(Huffman *)malloc(sizeof(Huffman)); f-\u003eLchild=NULL; f-\u003eRchild=NULL; f-\u003eLchild=z[k]; f-\u003eRchild=z[j]; f-\u003ei=f-\u003eLchild-\u003ei+f-\u003eRchild-\u003ei; t=z[k]=f; flag=0; } else{ if(flag==1){ f=(Huffman *)malloc(sizeof(Huffman)); f-\u003eLchild=NULL; f-\u003eRchild=NULL; f-\u003eLchild=p; f-\u003eRchild=z[j]; f-\u003ei=f-\u003eLchild-\u003ei+f-\u003eRchild-\u003ei; t=p=f; flag=0; } else{ if(s-\u003ei==l||s-\u003ei==r){ p=(Huffman *)malloc(sizeof(Huffman)); p-\u003eRchild=NULL; printf(\"%d\",s-\u003ei); p-\u003eLchild=s; p-\u003eRchild=(Huffman *)malloc(sizeof(Huffman)); p-\u003eRchild-\u003eLchild=p-\u003eRchild-\u003eRchild=NULL; if(s-\u003ei==l) p-\u003eRchild-\u003ei=r; else p-\u003eRchild-\u003ei=l; p-\u003ei=p-\u003eLchild-\u003ei+p-\u003eRchild-\u003ei; t=s=p; } else{ i++; R=(Huffman *)malloc(sizeof(Huffman)); L=(Huffman *)malloc(sizeof(Huffman)); z[i]=(Huffman *)malloc(sizeof(Huffman)); R-\u003eLchild=R-\u003eRchild=L-\u003eLchild=L-\u003eRchild=z[i]-\u003eLchild=z[i]-\u003eRchild=NULL; L-\u003ei=l; R-\u003ei=r; z[i]-\u003eLchild=L; z[i]-\u003eRchild=R; z[i]-\u003ei=z[i]-\u003eLchild-\u003ei+z[i]-\u003eRchild-\u003ei; t=z[i]; } } } Insert(t-\u003ei); if(head-\u003enext-\u003enext!=NULL){ l=min(head); Delete(head,l); r=min(head); Delete(head,r); } else{ break; } } return p; } void xianxu(Huffman *p){ if(p==NULL) return ; else{ printf(\"%d\\t\",p-\u003ei); xianxu(p-\u003eLchild); xianxu(p-\u003eRchild); } } void main(){ Huffman *p; p=InitHuffman(); xianxu(p); } ","date":"2020-03-05","objectID":"/linkedlist/:0:0","tags":["链表","数据结构"],"title":"链表","uri":"/linkedlist/"},{"categories":["c语言","人工智能"],"content":"A*算法解决8数码问题","date":"2020-03-04","objectID":"/eightcode/","tags":["启发式搜索","人工智能"],"title":"A*算法解决8数码问题","uri":"/eightcode/"},{"categories":["c语言","人工智能"],"content":"在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局，找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。 8数码要解决的问题 基本的棋子移动,不应当看做是空格(也就是图中的0)向四个方向移动,而不是看成其他4个棋子向空格移动,这样会增加难度. 启发式搜索的关键在于对每步的动作进行评估和在close表中出现过,若出现过则回朔到上一步,对每次的步骤进行评估,按照评估的价值对open表进行排序(这里采用插入排序). 具体步骤如下: （ 1 ）把初始节点 S0 放入 Open 表中， f(S0)=g(S0)+h(S0); （ 2 ）如果 Open 表为空，则问题无解，失败退出； • （ 3 ）把 Open 表的第一个节点取出放入 Closed 表，并记该节点为 n ； • （ 4 ）考察节点 n 是否为目标节点。若是，则找到了问题的解，成功退出； • （ 5 ）若节点 n 不可扩展，则转到第 (2) 步； • （ 6 ）扩展节点 n ，生成子节点 ni ( i =1,2, …… ) ，计算每一个子节点的估价值 f( ni ) ( i =1,2, …… ) ，并为每一个子节点设置指向父节点的指针，然后将这些子节点放入 Open 表中； • （ 7 ）根据各节点的估价函数值，对 Open 表中的全部节点按从小到大的顺序重新进行排序； • （ 8 ）转第 (2) 步。 #include\u003cstdio.h\u003e#include\u003cmalloc.h\u003e#include\u003cstdlib.h\u003e#define Lenth 3 char arr[Lenth*Lenth]; char end[Lenth*Lenth]; typedef struct EightNode{ char arr[Lenth*Lenth]; //8数码 struct EightNode *parents; //指针指向上个结点 int site; //位置 int number; //F(N) int ceng; //当前层数 }EN; typedef struct QueueNode{ EN *smallEightNode; struct QueueNode *next; }QN; void swap(char *a1,char *b1){ char t; t=*a1; *a1=*b1; *b1=t; } int up(char *a,int *Fan){ if(*Fan\u003cLenth){ return 0; } else{ swap(a+*Fan,a-Lenth+*Fan); *Fan=*Fan-Lenth; } return 1; } int down(char *a,int *Fan){ if(*Fan\u003eLenth*Lenth-Lenth-1){ return 0; } else{ swap(a+*Fan,a+*Fan+Lenth); *Fan=*Fan+Lenth; } return 1; } int left(char *a,int *Fan){ if(*Fan%Lenth==0){ return 0; } else{ swap(a+*Fan,a+*Fan-1); *Fan=*Fan-1; } return 1; } int right(char *a,int *Fan){ if(*Fan%Lenth==Lenth-1){ return 0; } else{ swap(a+*Fan,a+*Fan+1); *Fan=*Fan+1; } return 1; } void equator(char *p1,char *p2){ int i; for(i=0;i\u003cLenth*Lenth;i++){ *(p1+i)=*(p2+i); } } int adept(char *a){ int i; int sum=0; for(i=0;i\u003cLenth*Lenth;i++){ if(*(a+i)==end[i]){ sum++; } } return sum; } QN *open; QN *close; int k; QN *Delete(){ QN *p,*q; p=close; q=close-\u003enext; p-\u003enext=q-\u003enext; return q; } void CloseInsert(QN *L){ QN *p,*q; QN *s; s=(QN *)malloc(sizeof(QN)); s-\u003esmallEightNode=(EN *)malloc(sizeof(EN)); equator(s-\u003esmallEightNode-\u003earr,L-\u003esmallEightNode-\u003earr); s-\u003esmallEightNode-\u003eceng=L-\u003esmallEightNode-\u003eceng; s-\u003esmallEightNode-\u003esite=L-\u003esmallEightNode-\u003esite; s-\u003esmallEightNode-\u003enumber=L-\u003esmallEightNode-\u003enumber; s-\u003esmallEightNode-\u003eparents=L-\u003esmallEightNode-\u003eparents; s-\u003enext=NULL; p=close; q=close-\u003enext; if(q==NULL){ p-\u003enext=s; s-\u003enext=q; return ; } for(;q!=NULL\u0026\u0026q-\u003esmallEightNode-\u003enumber\u003c=s-\u003esmallEightNode-\u003enumber;){ p=p-\u003enext; q=q-\u003enext; } p-\u003enext=s; s-\u003enext=q; return; } int CloseIsUsed(QN *L){ //看close表中有没有该结点，如果有，以number小的为准 QN *q,*p; int i,po; p=close; q=close-\u003enext; while(q!=NULL){ po=0; for(i=0;i\u003cLenth*Lenth;i++) if(*(q-\u003esmallEightNode-\u003earr+i)!=*(L-\u003esmallEightNode-\u003earr+i)) po=1; if(po==0){ break;} p=p-\u003enext; q=q-\u003enext; } if(po==0){ if(L-\u003esmallEightNode-\u003enumber\u003cq-\u003esmallEightNode-\u003enumber){ p-\u003enext=q-\u003enext; CloseInsert(L); } return 0; } else{ return 1; } } void OpenInsert(QN *L){ QN *p,*q; QN *s; s=(QN *)malloc(sizeof(QN)); s-\u003esmallEightNode=(EN *)malloc(sizeof(EN)); equator(s-\u003esmallEightNode-\u003earr,L-\u003esmallEightNode-\u003earr); s-\u003esmallEightNode-\u003eceng=L-\u003esmallEightNode-\u003eceng; s-\u003esmallEightNode-\u003esite=L-\u003esmallEightNode-\u003esite; s-\u003esmallEightNode-\u003enumber=L-\u003esmallEightNode-\u003enumber; s-\u003enext=NULL; p=open; q=open-\u003enext; if(q==NULL){ p-\u003enext=s; s-\u003enext=q; return ; } for(;q!=NULL\u0026\u0026p-\u003esmallEightNode-\u003enumber\u003c=s-\u003esmallEightNode-\u003enumber;){ p=p-\u003enext; q=q-\u003enext; } p-\u003enext=s; s-\u003enext=q; return; } int OpenIsused(QN *L){ QN *p,*q; int i,po; p=open; q=open-\u003enext; while(q!=NULL){ po=0; for(i=0;i\u003cLenth*Lenth;i++) if(*(q-\u003esmallEightNode-\u003earr+i)!=*(L-\u003esmallEightNode-\u003earr+i)) po=1; if(po==0){ break;} p=p-\u003enext; q=q-\u003enext; } if(po==0){ if(L-\u003esmallEightNode-\u003enumber\u003eq-\u003esmallEightNode-\u003enumber){ p-\u003enext=q-\u003enext; OpenInsert(L); } return 0; } else{ return 1; } } int display(EN *g,int i){ int k; if(g-\u003eparents==NULL){ printf(\"step:%d\\n\",i); printf(\"********************************************************\\n\"); for(k=0;k\u003cLenth*Lenth;k++){ printf(\"\\t%c\",*(g-\u003earr+k)); if(k%Lenth==Lenth-1)printf(\"\\n\"); } printf(\"*******************************","date":"2020-03-04","objectID":"/eightcode/:0:0","tags":["启发式搜索","人工智能"],"title":"A*算法解决8数码问题","uri":"/eightcode/"},{"categories":["c语言","人工智能"],"content":"回朔法求8数码问题 在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局，找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。 8数码要解决的问题 基本的棋子移动,不应当看做是空格(也就是图中的0)向四个方向移动,而不是看成其他4个棋子向空格移动,这样会增加难度. #include\u003cstdio.h\u003e#include\u003cmalloc.h\u003echar arr[9]; char end[9]; char skip[9]; int Fan; typedef struct EightNode{ char arr[9]; struct EightNode *parents; struct EightNode *OL; struct EightNode *OR; struct EightNode *OU; struct EightNode *OD; int site; int number; }EN; void swap(char *a1,char *b1){ char t; t=*a1; *a1=*b1; *b1=t; } int up(char *a){ if(Fan\u003c3){ return 0; } else{ swap(a+Fan,a-3+Fan); } return 1; } int down(char *a){ if(Fan\u003e5){ return 0; } else{ swap(a+Fan,a+Fan+3); } return 1; } int left(char *a){ if(Fan%3==0){ return 0; } else{ swap(a+Fan,a+Fan-1); } return 1; } int right(char *a){ if(Fan%3==2){ return 0; } else{ swap(a+Fan,a+Fan+1); } return 1; } void equator(char *p1,char *p2){ int i; for(i=0;i\u003c9;i++){ *(p1+i)=*(p2+i); } } EN *head; void Init(int site){ int i,j,k,t,tmp,po,flag; int z,judg; int a,b; EN *NNN; EN *q,*p,*monitor; a=b=0; if(arr[0]==end[0]\u0026\u0026arr[1]==end[1]\u0026\u0026arr[2]==end[2])a=1; z=1; tmp=1; printf(\"请输入一个最大层数\"); scanf(\"%d\",\u0026t);getchar(); head=(EN *)malloc(sizeof(EN)); head-\u003enumber=1; p=monitor=NNN=(EN *)malloc(sizeof(EN)); NNN-\u003eOD=NNN-\u003eOL=NNN-\u003eOR=NNN-\u003eOU=NNN-\u003eparents=NULL; equator(NNN-\u003earr,skip); head-\u003esite=site; p=head; head-\u003eOU=head-\u003eOD=head-\u003eOL=head-\u003eOR=NNN; head-\u003eparents=NULL; equator(head-\u003earr,arr); while(1){ judg=0; printf(\"\\n\"); flag=0; po=0; Fan=p-\u003esite; if(a==1\u0026\u0026Fan\u003c5){ p-\u003eOU=NULL; } if(p-\u003eOU==NNN\u0026\u0026flag==0){ q=(EN *)malloc(sizeof(EN)); equator(q-\u003earr,p-\u003earr); if(up(q-\u003earr)==0){ printf(\"不被允许的操作，向上越界\"); p-\u003eOU=NULL; free(q); } else{ Fan=Fan-3; q-\u003esite=Fan; printf(\"成功向上移动\"); q-\u003eOD=q-\u003eOL=q-\u003eOR=q-\u003eOU=q-\u003eparents=NNN; q-\u003eparents=p; q-\u003enumber=q-\u003eparents-\u003enumber+1; p-\u003eOU=q; p=q; judg=1; } flag=1; printf(\"\\n\"); } if(p-\u003eOD==NNN\u0026\u0026flag==0){ q=(EN *)malloc(sizeof(EN)); equator(q-\u003earr,p-\u003earr); if(down(q-\u003earr)==0){ printf(\"不被允许的操作，向下越界\"); p-\u003eOD=NULL; free(q); } else{ Fan=Fan+3; q-\u003esite=Fan; printf(\"成功向下移动\"); q-\u003eOD=q-\u003eOL=q-\u003eOR=q-\u003eOU=q-\u003eparents=NNN; q-\u003eparents=p; q-\u003enumber=q-\u003eparents-\u003enumber+1; p-\u003eOD=q; p=q; judg=2; } flag=1; } if(p-\u003eOL==NNN\u0026\u0026flag==0){ q=(EN *)malloc(sizeof(EN)); equator(q-\u003earr,p-\u003earr); if(left(q-\u003earr)==0){ printf(\"不被允许的操作，向左越界\"); p-\u003eOL=NULL; free(q); } else{ Fan=Fan-1; q-\u003esite=Fan; printf(\"成功向左移动\"); q-\u003eOD=q-\u003eOL=q-\u003eOR=q-\u003eOU=q-\u003eparents=NNN; q-\u003eparents=p; q-\u003enumber=q-\u003eparents-\u003enumber+1; p-\u003eOL=q; p=q; judg=3; } flag=1; } if(p-\u003eOR==NNN\u0026\u0026flag==0){ q=(EN *)malloc(sizeof(EN)); equator(q-\u003earr,p-\u003earr); if(right(q-\u003earr)==0){ printf(\"不被允许的操作，向右越界\"); p-\u003eOR=NULL; free(q); } else{ Fan=Fan+1; q-\u003esite=Fan; printf(\"成功向右移动\"); q-\u003eOD=q-\u003eOL=q-\u003eOR=q-\u003eOU=q-\u003eparents=NNN; q-\u003eparents=p; q-\u003enumber=q-\u003eparents-\u003enumber+1; p-\u003eOR=q; p=q; judg=4; } flag=1; } printf(\"\\n\"); for(k=0;k\u003c9;k++){ if(end[k]!=p-\u003earr[k]){ po=1; break; } printf(\"%c,%c\\t\",p-\u003earr[k],end[k]); if(k%3==2){ printf(\"\\n\"); } } printf(\"这个矩阵层数是：%d\\n\",p-\u003enumber); if(po==0){ printf(\"\\n找到了！\"); break; } if(p==head\u0026\u0026head-\u003eOD!=NNN\u0026\u0026head-\u003eOL!=NNN\u0026\u0026head-\u003eOR!=NNN\u0026\u0026head-\u003eOU!=NNN){ printf(\"\\n没找到！\"); break; } if(p-\u003eOD!=NNN\u0026\u0026p-\u003eOL!=NNN\u0026\u0026p-\u003eOR!=NNN\u0026\u0026p-\u003eOU!=NNN){ printf(\"全为空\"); monitor-\u003eOD=p; p=p-\u003eparents; monitor-\u003eOD=NULL; } if(p-\u003enumber\u003et){ p=p-\u003eparents; if(judg==1){ p-\u003eOU=NULL; } if(judg==2){ p-\u003eOD=NULL; } if(judg==3){ p-\u003eOL=NULL; } if(judg==4){ p-\u003eOR=NULL; } } } } void main(){ int i,k; for(i=0;i\u003c9;i++){ scanf(\"%c\",arr+i);getchar(); if(arr[i]==' ')k=i; } for(i=0;i\u003c9;i++){ scanf(\"%c\",end+i);getchar(); } Init(k); } ","date":"2020-03-04","objectID":"/eightcodelimit/:0:0","tags":["回朔法","人工智能"],"title":"回朔法解决8数码问题","uri":"/eightcodelimit/"},{"categories":["java","JVM"],"content":"JVM的学习记录 ","date":"2020-03-02","objectID":"/demo1/:1:0","tags":["jvm"],"title":"java虚拟机学习","uri":"/demo1/"},{"categories":["java","JVM"],"content":"JVM的生命周期 JAVA虚拟机的启动 JAVA虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的。初始类中会加载很多内容。 JAVA虚拟机的执行 程序开始执行时他才运行,程序结束时停止运行 所谓的执行JAVA程序,真真正正运行的是一个JAVA虚拟机的进程。可以有多个进程，这并不冲突。 JAVA虚拟机的结束(结束JAVA虚拟机进程) 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致JAVA虚拟机进程终止 某线程调用Runtime类或System类的exit方法(exit方法仍然是调用的Runtime的halt方法),或Runtime类的halt方法,并且JAVA安全管理器也允许这次exit或halt方法. 该方法的本质还是调用halt0(int status)的本地方法. JNI(Java Native Interface)规范描述了用JNI Invocation API 来加载或卸载 Java虚拟机时,Java虚拟机的退出情况。 主流虚拟机都是解释+编译，如果把解释比如成步行，编译比如成坐公交，那么坐公交等待时间太长，步行虽然不用等待，但终归没有坐公交快。所以现在主流的虚拟机都是解释+编译！ hotspot虚拟机 默认的虚拟机都是Hotspot,底层有通过计数器找到最具编译价值代码,触发即时编译或栈上替换。 通过编译器和解释器同时工作，在最优化的程序响应时间与最佳执行性能中取得平衡。 JRockit JRockit是世界上最快的Java虚拟机。 ","date":"2020-03-02","objectID":"/demo1/:1:1","tags":["jvm"],"title":"java虚拟机学习","uri":"/demo1/"},{"categories":["java","JVM"],"content":"类加载过程 加载 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结果转化为方法去的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口 链接 验证 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求,保证被加载类的正确性,不会危害虚拟机自身安全. 主要包含四中验证,文件格式验证,元数据验证,字节码验证,符号引用验证. 准备 为类变量分配内存并且设置该类变量的默认初始值,即零值. 这里不包含用final修饰的static,因为final在编译的时候就会分配了,准备阶段会显式初始化 这里不会为实例变量分配初始化,类变量会分配在方法区中,而实例变量是会随着对象一起分配到Java堆中. 解析 将常量池内的符号引用转换为直接引用的过程. 事实上,解析操作往往会伴随着JVM在执行完初始化之后再执行. 符号引用就是一组符号来描述所引用的目标.符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中.直接引用就是直接指向目标的指针,相对偏移量或一个简洁定位到目标的句柄. 解析动作主要针对类或接口,字段,类方法,接口方法,方法型等.对应常量池中的CONSTANT_Class_info,CONSTANT_Fieldref_info,CONSTANT_Methodref_info等. 初始化 初始化阶段就是执行类构造器方法()过程. 此方法不需要定义,是javac编译器自动收集类中的所有类变量的复制动作和静态代码块中的语句合并而来. 构造器方法中指令按语句在原文件中出现的顺序执行. ()不同于类的构造器.(关联:构造器是虚拟机视角下的()) 若该类具有父类,JVM会保证子类的()执行前,父类的()已经执行完毕. 虚拟机必须保证一个类的()方法在多线程下被同步加锁. ","date":"2020-03-02","objectID":"/demo1/:1:2","tags":["jvm"],"title":"java虚拟机学习","uri":"/demo1/"},{"categories":["java","JVM"],"content":"类加载器的分类 JVM支持两种类型的类加载器,分别为引导类加载器(Bootstrap ClassLoader)和自定义类加载器(UserDefined ClassLoader). JVM虚拟机将所有派生于抽象类CLassLoader的类加载器都划分为自定义类加载器. 启动类加载器、扩展类加载器、系统类加载器、用户自定义加载器，这四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。 启动类加载器(引导类加载器，Bootstrap ClassLoader) 这个类加载使用c/c++语言实现的,嵌套在JVM内部,所以getClassLoader会变成null值. 它用来加载Java的核心库(JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容),用于提供JVM自身需要的类. 并不继承自java.lang.ClassLoader,没有父加载器. 加载扩展类和应用程序类加载器,并指定为他们的父类加载器. 出于安全考虑,Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 扩展类加载器(Extension ClassLoader) Java语言编写,由sun.misc.Launcher$ExtClassLoader实现. 派生于ClassLoader类 父类加载器为启动类加载器 从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库.如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载. 应用程序类加载器(系统类加载器,APPClassLoader) java语言编写,由sun.misc.Launcher$APPClassLoader实现 派生于ClassLoader类 父类加载器为扩展类加载器 它负责加载环境变量classpath或系统属性 java.class.path指定路径下的类库 该类加载是程序中默认的类加载器,一般来说,Java应用的类都是由它来完成加载 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器 ","date":"2020-03-02","objectID":"/demo1/:1:3","tags":["jvm"],"title":"java虚拟机学习","uri":"/demo1/"}]